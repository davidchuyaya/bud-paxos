# acceptor

######################## relation definitions
# EDB
id(id)
partitionID(partition)
ballotGeq(id1, num1, id2, num2) # true if num1 >= num2 or (num1 = num2 and id1 >= id2)

# IDB
ballotCache(et, id, num, l, t) # new stucture for local reads in phase 2. et = event timestamp
NewestBallotTime(et, l, t)
NewestBallot(id, num, l, t)
log(payload, slot, ballotID, ballotNum, l, t)
LogSize(size, l, t)
LogEntryMaxBallotNum(slot, ballotNum, l, t)
LogEntryMaxBallot(slot, ballotID, ballotNum, l, t)

# copied from proposer
p1a(proposerID, ballotID, ballotNum, l, t) # proposerID is the location of the proposer
p1b(acceptorID, logSize, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t) # NOTE: logSize necessary because p1b can't send entire log back in 1 msg
p1bLog(acceptorID, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, l, t)
p2a(proposerID, payload, slot, ballotID, ballotNum, l, t) # proposerID is the location of the proposer
p2b(acceptorID, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t)

decoupledP1a(et, proposerID, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t) # et = event timestamp
######################## end relation definitions


ballotCache(et, i, n, l, t') :- ballotCache(et, i, n, l, t), succ(t, t')
log(p, slot, ballotID, ballotNum, l, t') :- log(p, slot, ballotID, ballotNum, l, t), succ(t, t')



######################## reply to p1a 
LogSize(count<slot>, l, t) :- log(_, slot, _, _, l, t)
ballotCache(et, maxBallotID, maxBallotNum, l, t) :- decoupledP1a(et, proposerID, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t)
p1b(i, size, ballotID, ballotNum, maxBallotID, maxBallotNum, proposerID, t') :- decoupledP1a(_, proposerID, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t), id(i), LogSize(size, l, t), choose(_, t')

# NOTE: Can be pushed to proposer in Paxos made moderately complex
LogEntryMaxBallotNum(slot, max<ballotNum>, l, t) :- log(_, slot, _, ballotNum, l, t)
LogEntryMaxBallot(slot, max<ballotID>, ballotNum, l, t) :- LogEntryMaxBallotNum(slot, ballotNum, l, t), log(_, slot, ballotID, ballotNum, l, t)

# send back entire log 
p1bLog(i, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, proposerID, t') :- id(i), log(payload, slot, payloadBallotID, payloadBallotNum, l, t), LogEntryMaxBallot(slot, payloadBallotID, payloadBallotNum, l, t), decoupledP1a(_, proposerID, ballotID, ballotNum, _, _, l, t), choose(_, t')
######################## end reply to p1a 



######################## reply to p2a
NewestBallotTime(max<et>, l, t) :- ballotCache(et, _, _, l, t)
NewestBallot(id, num, l, t) :- ballotCache(et, id, num, l, t), NewestBallotTime(et, l, t)
log(payload, slot, ballotID, ballotNum, l, t) :- p2a(_, payload, slot, ballotID, ballotNum, l, t), NewestBallot(maxID, maxNum, l, t), ballotID == maxID, ballotNum == maxNum
p2b(i, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, proposerID, t') :- p2a(proposerID, payload, slot, ballotID, ballotNum, l, t), id(i), NewestBallot(maxBallotID, maxBallotNum, l, t),choose(_, t')
######################## end reply to p2a