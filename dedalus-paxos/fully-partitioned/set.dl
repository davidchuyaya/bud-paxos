# Before
client_in(sender, val, l, t)
client_out(val, l, t)

set(val, l, t)
set(val, l, t') :- set(val, l, t), succ(t, t')
set(val, l, t) :- client_in(_, val, l, t)
client_out(val, sender, t') :- set(val, l, t), client_in(sender, val, l, t), choose(_, t')



# Partitioning Rule: 
#    Hypothesis for equivalence constraints:
#    Random input partitioning: works if each input record is "independent" in the codeblock.
#    Union output partitioning: works if each output record is "independent"
partitions(p)
# 1. HOW/WHAT TO PARTITION (INTERNAL)
# add partition to all internal state
set(p, val, l, t)
# add partition to all rules
set(p, val, l, t') :- set(p, val, l, t), succ(t, t')

# 2. HOW TO PARTITION INPUT: random
set(choose<p>, val, l, t) :- client_in(_, val, l, t), partitions(p)
# 3. HOW TO COLLECT OUTPUT: union
client_out(val, sender, t') :- set(p, val, l, t), client_in(sender, val, l, t), choose(_, t')





# Set that returns whether the item was already stored
client_out(val, exists, l, t)
true(t)
false(f)

client_out(val, t, l, t') :- set(val, l, t), client(sender, val, l, t), true(t), choose(_, t')
client_out(val, f, l, t') :- Â¬set(val, l, t), client(sender, val, l, t), false(f), choose(_, t')