# Before
client_in(sender, val, l, t)
client_out(val, num, l, t)
nat(num)

log(val, num, l, t)
MinHole(num, l, t)
client_cache(sender, val, l, t)
ChosenPayload(sender, val, l, t)

log(val, num, l, t') :- log(val, num, l, t), succ(t, t')
client_cache(sender, val, l, t) :- client_in(sender, val, l, t)
client_cache(sender, val, l, t') :- client_cache(sender, val, l, t), succ(t, t')

#Lock a slot
MinHole(min<num>, l, t) :- ¬log(_, num, l, t), nat(num)
#Choose exactly one unassigned proposal
ChosenPayload(choose<sender, val>, l, t) :- client_cache(sender, val, l, t), ¬log(val, _, l, t)

# put proposal in slot and return info to sender
log(val, num, l, t) :- ChosenPayload(_, val, l, t), MinHole(num, l, t)
client_out(val, num, sender, t) :- log(val, num, l, t), ChosenPayload(sender, val, l, t), choose(_, t')



########### Alternative to janky "queue"
ChosenPayload(choose<sender, val>, l, t) :- client_cache(sender, val, l, t)
client_cache(sender, val, l, t') :- client_cache(sender, val, l, t), ¬ChosenPayload(sender, val, l, t), succ(t, t')

########### Alternative to separate "numbers used" from payloads
usedSlots(num, l, t)
usedSlots(num, l, t) :- MinHole(num, l, t), ChosenPayload(_, _, l, t) # Client input is a "trigger" that a slot has been used
MinHole(min<num>, l, t) :- ¬usedSlots(num, l, t), nat(num)


########### In both alternatives, negation is unavoidable.
# Queue: Shifted negation from log to client_cache. Still recursive wrt ChosenPayload (it chooses what has not been chosen before)
# Separating MinHole from log: usedSlots acts like log with just the numbers column. Still influenced (triggered) by clieint input. Value write turned into "trigger" because client input is not important (not joined).