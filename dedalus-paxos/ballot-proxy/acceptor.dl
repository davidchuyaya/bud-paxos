# acceptor

######################## relation definitions
# EDB
id(id)
slotPartition(a, s, p) # a = acceptorID, because each acceptor has its own set of partition locations
proxy(l, l')
ballotGeq(id1, num1, id2, num2) # true if num1 >= num2 or (num1 = num2 and id1 >= id2)

# IDB
ballots(p, id, num, l, t) 
log(payload, slot, ballotID, ballotNum, l, t)
LogSize(p, size, l, t)
LogEntryMaxBallotNum(slot, ballotNum, l, t)
LogEntryMaxBallot(slot, ballotID, ballotNum, l, t)
MaxBallotNum(p, num, l, t)
MaxBallot(p, id, num, l, t)

processedIndices(p, i, l, t) # Initialized with i = 0 at each partition
MaxProcessedIndex(p, i, l, t)
NextP1a(p, order, proposerID, id, num, l, t)
MaxReceivedCommit(p, i, l, t)
Unfreeze(p, l, t)

# copied from proposer
p1a(p, proposerID, ballotID, ballotNum, l, t)
p1b(p, order, acceptorID, logSize, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t)
p1bLog(p, order, acceptorID, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, l, t)
p2a(proposerID, payload, slot, ballotID, ballotNum, l, t) 
p2b(acceptorID, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t)
# new channels
p1aVote(p, proposerID, ballotID, ballotNum, l, t)
p1aCommit(p, order, proposerID, ballotID, ballotNum, l, t)
######################## end relation definitions



ballots(p, i, n, l, t') :- ballots(p, i, n, l, t), succ(t, t')
log(p, slot, ballotID, ballotNum, l, t') :- log(p, slot, ballotID, ballotNum, l, t), succ(t, t')

# keep p1a to check for commits
p1a(p, proposerID, ballotID, ballotNum, l, t') :- p1a(p, proposerID, ballotID, ballotNum, l, t), succ(t, t')
p1aCommit(p, order, proposerID, ballotID, ballotNum, l, t') :- p1aCommit(p, order, proposerID, ballotID, ballotNum, l, t), succ(t, t')
processedIndices(p, i, l, t') :- processedIndices(p, i, l, t), succ(t, t')
# freeze
p2a(proposerID, payload, slot, ballotID, ballotNum, l, t') :- p2a(proposerID, payload, slot, ballotID, ballotNum, l, t), succ(t, t'), slotPartition(l, slot, p), Â¬Unfreeze(p, l, t)



######################## reply to p1a 
# routing to proxy
p1aVote(p, proposerID, ballotID, ballotNum, l', t') :- p1a(p, proposerID, ballotID, ballotNum, l, t), proxy(l, l'), choose(_, t')
# processing p1a in order. Can process p1a as soon as it's committed & all previous p1as have been processed
MaxProcessedIndex(p, max<i>, l, t) :- processedIndices(p, i, l, t)
NextP1a(p, next, proposerID, id, num, l, t) :- MaxProcessedIndex(p, i, l, t), next = i + 1, p1aCommit(p, next, proposerID, id, num, l, t)
processedIndices(p, i, l, t') :- NextP1a(p, i, _, _, _, l, t), succ(t, t')
# non-replicated inputs must wait until all outstanding p1as have been processed
MaxReceivedCommit(p, max<i>, l, t) :- p1aCommit(p, i, _, _, _, l, t)
Unfreeze(p, l, t) :- MaxProcessedIndex(p, i, l, t), MaxReceivedCommit(p, i, l, t) 

# original code
ballots(p, id, num, l, t) :- NextP1a(p, _, _, id, num, l, t)
MaxBallotNum(p, max<num>, l, t) :- ballots(p, _, num, l, t)
MaxBallot(p, max<id>, num, l, t) :- MaxBallotNum(p, num, l, t), ballots(p, id, num, l, t)
LogSize(p, count<slot>, l, t) :- log(_, slot, _, _, l, t), slotPartition(slot, p)
p1b(p, order, i, size, ballotID, ballotNum, maxBallotID, maxBallotNum, proposerID, t') :- NextP1a(p, order, proposerID, ballotID, ballotNum, l, t), id(i), LogSize(p, size, l, t), MaxBallot(p, maxBallotID, maxBallotNum, l, t)

LogEntryMaxBallotNum(slot, max<ballotNum>, l, t) :- log(_, slot, _, ballotNum, l, t)
LogEntryMaxBallot(slot, max<ballotID>, ballotNum, l, t) :- LogEntryMaxBallotNum(slot, ballotNum, l, t), log(_, slot, ballotID, ballotNum, l, t)

# send back entire log 
p1bLog(i, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, proposerID, t') :- id(i), log(payload, slot, payloadBallotID, payloadBallotNum, l, t), LogEntryMaxBallot(slot, payloadBallotID, payloadBallotNum, l, t), NextP1a(p, _, proposerID, ballotID, ballotNum, l, t), slotPartition(l, slot, p), choose(_, t')
######################## end reply to p1a 



######################## reply to p2a
# Any rule that uses MaxBallot is guaranteed to only run once all ballots have been processed
log(payload, slot, ballotID, ballotNum, l, t) :- p2a(_, payload, slot, ballotID, ballotNum, l, t), MaxBallot(p, maxID, maxNum, l, t), ballotGeq(ballotID, ballotNum, maxID, maxNum), slotPartition(l, slot, p), Unfreeze(p, l, t) 
p2b(i, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, proposerID, t') :- p2a(proposerID, payload, slot, ballotID, ballotNum, l, t), id(i), MaxBallot(p, maxBallotID, maxBallotNum, l, t), slotPartition(l, slot, p), Unfreeze(p, l, t), choose(_, t')
######################## end reply to p2a