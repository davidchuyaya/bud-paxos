# acceptor

######################## relation definitions
# EDB
id(id)
# NOTE: Start modified
slotPartition(s, p)
# NOTE: End modified
ballotGeq(id1, num1, id2, num2) # true if num1 >= num2 or (num1 = num2 and id1 >= id2)

# IDB
# NOTE: Start modified
ballots(p, id, num, l, t) 
# NOTE: End modified
log(payload, slot, ballotID, ballotNum, l, t)
LogSize(p, size, l, t)
LogEntryMaxBallotNum(slot, ballotNum, l, t)
LogEntryMaxBallot(slot, ballotID, ballotNum, l, t)
# NOTE: Start modified
MaxBallotNum(p, num, l, t)
MaxBallot(p, id, num, l, t)
# NOTE: End modified

# copied from proposer
# NOTE: Start modified
p1a(p, proposerID, ballotID, ballotNum, l, t) # proposerID is the location of the proposer
p1b(p, acceptorID, logSize, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t) # NOTE: logSize necessary because p1b can't send entire log back in 1 msg
# NOTE: End modified
p1bLog(acceptorID, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, l, t)
p2a(proposerID, payload, slot, ballotID, ballotNum, l, t) # proposerID is the location of the proposer
p2b(acceptorID, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t)
######################## end relation definitions



ballots(p, i, n, l, t') :- ballots(p, i, n, l, t), succ(t, t')
log(p, slot, ballotID, ballotNum, l, t') :- log(p, slot, ballotID, ballotNum, l, t), succ(t, t')



######################## reply to p1a 
# NOTE: Start modified
ballots(p, id, num, l, t) :- p1a(p, _, id, num, l, t)
MaxBallotNum(p, max<num>, l, t) :- ballots(p, _, num, l, t) 
MaxBallot(p, max<id>, num, l, t) :- MaxBallotNum(p, num, l, t), ballots(p, id, num, l, t)
LogSize(p, count<slot>, l, t) :- log(_, slot, _, _, l, t), slotPartition(slot, p)
p1b(p, i, size, ballotID, ballotNum, maxBallotID, maxBallotNum, proposerID, t') :- p1a(p, proposerID, ballotID, ballotNum, l, t), id(i), LogSize(p, size, l, t), MaxBallot(p, maxBallotID, maxBallotNum, l, t), choose(_, t')
# NOTE: End modified

# NOTE: Can be pushed to proposer in Paxos made moderately complex
LogEntryMaxBallotNum(slot, max<ballotNum>, l, t) :- log(_, slot, _, ballotNum, l, t)
LogEntryMaxBallot(slot, max<ballotID>, ballotNum, l, t) :- LogEntryMaxBallotNum(slot, ballotNum, l, t), log(_, slot, ballotID, ballotNum, l, t)

# send back entire log 
p1bLog(i, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, proposerID, t') :- id(i), log(payload, slot, payloadBallotID, payloadBallotNum, l, t), LogEntryMaxBallot(slot, payloadBallotID, payloadBallotNum, l, t), p1a(p, proposerID, ballotID, ballotNum, l, t), slotPartition(slot, p), choose(_, t')
######################## end reply to p1a 



######################## reply to p2a
# Any rule that uses MaxBallot is guaranteed to only run once all ballots have been processed
# NOTE: Start modified
log(payload, slot, ballotID, ballotNum, l, t) :- p2a(_, payload, slot, ballotID, ballotNum, l, t), MaxBallot(p, maxID, maxNum, l, t), ballotGeq(ballotID, ballotNum, maxID, maxNum), slotPartition(slot, p) 
# NOTE: Can just use equal
p2b(i, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, proposerID, t') :- p2a(proposerID, payload, slot, ballotID, ballotNum, l, t), id(i), MaxBallot(p, maxBallotID, maxBallotNum, l, t), slotPartition(slot, p), choose(_, t')
# NOTE: End modified
######################## end reply to p2a