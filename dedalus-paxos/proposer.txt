# proposer
# Syntax note: Capital = scratch (not persisted)
# Assumption: count on empty relation returns 0. Undefined if there are group-by attributes (returns null in SQL for those columns)

######################## relation definitions
# EDB
id(id) # increment from 1
acceptors(id)
quorum(size)
ballotGeq(id1, num1, id2, num2) # true if num1 >= num2 or (num1 = num2 and id1 >= id2)
timeout(t) # resends p1b after this many seconds. Must be larger than # of proposers, since we check its equality with id
nat(n) # all natural numbers

# IDB
client_in(payload, l, t)
client_out(payload, seq, l, t)

ballot(num, l, t) # Assume starts with num = 0
NewBallot(num, l, t)
IsLeader(l, t) # bool, has an entry for this time if we are leader
CountMatchingP1bs(c, l, t) # number of p1bs that have us as leader
MaxP1bBallotNum(num, l, t)
MaxP1bBallot(id, num, l, t) # largest ballot seen in p1bs
MaxP2bBallotNum(num, l, t)
MaxP2bBallot(id, num, l, t) # largest ballot seen in p2bs
timeoutCounter(num, l, t) # for stable leader election to prevent preemption. Assume starts with num = 0
P1bMatchingEntry(payload, seq, c, id, num, l, t) # how many p1bs have this payload for this seq num? Note that same payload & different ballot = treated as different. This is fine, since uncommitted entries will be resent to every acceptor with the same ballot.
P1bSeq(seq, c, l, t) # how many p1bs have we received for this seq? Once we hit quorum, can make decision
P1bLargestEntryBallotNum(seq, num, l, t)
P1bLargestEntryBallot(seq, id, num, l, t) # largest ballot per slot in p1bs
P1bResentEntries(payload, seq, l, t) # entries to resend p2as for, based on uncommitted entries in p1b
P1bLogFromAcceptor(acceptorID, c, l, t) # count of p1b entries received from each acceptor
CanSendP2a(l, t) # true once all p1b logs have been received from acceptors who sent p1bs

proposedLog(payload, seq, l, t) # potentially uncommitted entries. Re-create on re-election 
payloads(payload, l, t) # all payloads ever received from client. On leader re-election, re-propose whatever isn't in the p1bs
MinLogHole(seq, l, t) # seq num of smallest hole in log
ChosenPayload(payload, l, t) # payload to propose in this timestep
CountMatchingP2bs(payload, seq, c, l, t) # number of p2bs per entry that still have us as leader

p1a(proposerID, ballotID, ballotNum, l, t)
p1b(acceptorID, logSize, ballotID, ballotNum, l, t) # NOTE: logSize necessary because p1b can't send entire log back in 1 msg
p1bLog(acceptorID, payload, seq, payloadBallotID, payloadBallotNum, ballotID, ballotNum, l, t)
p2a(proposerID, payload, seq, ballotID, ballotNum, l, t)
p2b(acceptorID, payload, seq, ballotID, ballotNum, l, t)
######################## end relation definitions



p1b(a, l, i, n, l, t') :- p1b(a, l, i, n, l, t), succ(t, t')
p1bLog(a, p, s, pi, pn, i, n, l, t') :- p1bLog(a, p, s, pi, pn, i, n, l, t), succ(t, t')
p2b(p, s, i, n, l, t') :- p2b(p, s, i, n, l, t), succ(t, t')
payloads(p, l, t) :- client_in(p, l, t)
payloads(p, l, t') :- payloads(p, l, t), succ(t, t')



######################## stable leader election 
CountMatchingP1bs(count<acceptorID>, l, t) :- id(i), ballot(num, l, t), p1b(acceptorID, _, i, num, l, t)
MaxP1bBallotNum(max<num>, l, t) :- p1b(_, _, _, num, l, t)
MaxP1bBallot(max<id>, num, l, t) :- MaxP1bBallotNum(num, l, t), p1b(_, _, id, num, l, t)
MaxP2bBallotNum(max<num>, l, t) :- p2b(_, _, _, num, l, t)
MaxP2bBallot(max<id>, num, l, t) :- MaxP2bBallotNum(num, l, t), p2b(_, _, id, num, l, t)
IsLeader(l, t) :- CountMatchingP1bs(c, l, t), quorum(size), c >= size, id(i), ballot(num, l, t), MaxP1bBallot(maxId1, maxNum1, l, t), ballotGeq(i, num, maxId1, maxNum1), MaxP2bBallot(maxId2, maxNum2, l, t), ballotGeq(i, num, maxId2, maxNum2)
# only resend p1a if we're not leader AND timeout counter reaches some magic number
NewBallot(newNum, l, t) :- id(i), ballot(num, l, t), ¬IsLeader(l, t), timeoutCounter(counter, l, t), counter == id, newNum = num + 1 
p1a(i, num, a, t') :- id(i), NewBallot(num, l, t), acceptors(a), choice(_, t')
ballot(num, l, t') :- NewBallot(num, l, t), succ(t, t')
ballot(num, l, t') :- ballot(num, l, t), ¬NewBallot(newNum, l, t), succ(t, t')
# increment timeout counter
timeoutCounter(nextNum, l, t') :- timeoutCounter(num, l, t), timeout(tout), nextNum = (num + 1) % tout, succ(t, t')
######################## end stable leader election 



######################## reconcile p1b log with local log
P1bMatchingEntry(payload, seq, count<acceptorID>, payloadBallotID, payloadBallotNum, l, t) :- p1bLog(acceptorID, payload, seq, payloadBallotID, payloadBallotNum, i, num, l, t), id(i), ballot(num, l, t) # only check if p1b ballot = our current ballot
# what was committed = store in local log. Note: Don't need to worry about overwriting; it's impossible to have f+1 matching for the same slot and another payload with a higher ballot; therefore this slot must already have the same payload (maybe with a lower ballot)
proposedLog(payload, seq, l, t) :- P1bMatchingEntry(payload, seq, c, i, num, l, t), quorum(size), c >= size

# what was not committed = find max ballot, store in local log, resend 
P1bSeq(seq, count<acceptorID>, l, t) :- p1bLog(acceptorID, _, seq, _, _, i, num, l, t), id(i), ballot(num, l, t)
P1bLargestEntryBallotNum(seq, max<payloadBallotNum>, l, t) :- p1bLog(_, _, seq, _, payloadBallotNum, i, num, l, t), id(i), ballot(num, l, t)
P1bLargestEntryBallot(seq, max<payloadBallotID>, payloadBallotNum, l, t) :- P1bLargestEntryBallotNum(seq, payloadBallotNum, l, t), p1b(_, _, seq, payloadBallotID, payloadBallotNum, i, num, l, t), id(i), ballot(num, l, t)
ResentEntries(payload, seq, l, t) :- P1bLargestEntryBallot(seq, payloadBallotID, payloadBallotNum, l, t), p1bLog(_, payload, seq, payloadBallotID, payloadBallotNum, i, num, l, t), id(i), ballot(num, l, t), IsLeader(l, t), P1bSeq(seq, c, l, t), quorum(size), c >= size, ¬proposedLog(_, seq, l, t) # does not explicitly avoid resending committed entries, since proposedLog is negated, which means that committed entries (which are written to proposedLog in the same timestep) must be in an earlier strata and are implicitly avoided
proposedLog(payload, seq, l, t') :- ResentEntries(payload, seq, l, t), succ(t, t') # must be succ because proposedLog is negated in ResentEntries
p2a(i, payload, seq, i, num, a, t') :- ResentEntries(payload, seq, l, t), id(i), ballot(num, l, t), acceptors(a), choose(_, t')
# only persist proposedLog if we're the leader. This way, when we lose election, the proposals are refreshed based on p1bs
proposedLog(p, s, l, t') :- proposedLog(p, s, l, t), IsLeader(l, t), succ(t, t')
######################## end reconcile p1b log with local log



######################## send p2as 
# cannot send new p2as until all p1b acceptor logs are received; otherwise might miss pre-existing entry
P1bLogFromAcceptor(acceptorID, count<seq>, l, t) :- p1bLog(acceptorID, _, seq, _, _, i, num, l, t), id(i), ballot(num, l, t)
CanSendP2a(l, t) :-  ¬P1bLogFromAcceptor(acceptorID, receivedCount, l, t), p1b(acceptorID, logSize, i, num, l, t), id(i), ballot(num, l, t), receivedCount < logSize

MinLogHole(min<seq>, l, t) :- ¬proposedLog(_, seq, l, t), nat(seq)
ChosenPayload(choose<payload>, l, t) :- payloads(payload, l, t), ¬proposedLog(payload, _, l, t), IsLeader(l, t), CanSendP2a(l, t)
p2a(i, payload, seq, i, num, a, t') :- ChosenPayload(payload, l, t), MinLogHole(seq, l, t), id(i), ballot(num, l, t), acceptors(a), choose(_, t')
proposedLog(payload, seq, l, t') :- ChosenPayload(payload, l, t), MinLogHole(seq, l, t), succ(t, t')
######################## end send p2as 



######################## process p2bs
CountMatchingP2bs(payload, seq, count<acceptorID>, l, t) :- p2b(acceptorID, payload, seq, i, num, l, t), id(i), ballot(num, l, t) # only count p2bs if the acceptor thinks we're the leader. Ensures p2bs are "up-to-date"
client_out(payload, seq, l, t) :- CountMatchingP2bs(payload, seq, c, l, t), quorum(size), c >= size
######################## end process p2bs