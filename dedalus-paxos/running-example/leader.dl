# Receive input
# Sign input (expensive)
# Broadcast signed message to participants
# Receive replica outputs
# Create signature certificate
# Send certificate to client


######################## relation definitions
# EDBs
client(c)
storageNodes(r)
numNodes(n)
sign(msg, sig, l) # sign(msg, l) = sig

# client APIs
in(value, l, t)
outCert(c, v, coll, l, t) # certificate of signatures
outInconsistent(v, l, t)

# communication with replicas
toStorages(v, lSig, l, t) # lSig = leader sig
fromStorages(r, sig, v, coll, l, t) # r = replica ID

# internal state
acks(r, sig, v, coll, l, t)
numACKs(cnt, v, coll, l, t)
certs(cert, v, coll, l, t)

######################## rules
# Sugared syntax: exclude all location and time. Use @async(l) for sends
# persistence
persist[acks]
toStorage(v,lSig)@async(s) :- in(v), sign(v,lSig), storageNodes(s)
acks(s,sig,v,coll) :- fromStorage(s,sig,v,coll)
numACKs(count<s>,v,coll) :- acks(s,_,v,coll)
certs(cert<sig>,v,coll) :- acks(_,sig,v,coll)
outCert(ce,v,coll,h)@async(c) :- certs(ce,v,coll), numACKs(cnt,v,coll), numNodes(cnt), client(c)
outInconsistent(v)@async(c) :- acks(_,_,v,coll1), acks(_,_,v,coll2), coll1 != coll2, client(c)