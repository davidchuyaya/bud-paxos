nat(n) # can be any arbitrary collection of finite/infinite values?
cycle(n, l, t)
client_in(client, payload, l, t)
client_out(payload, num, l, t)

cycle(choose<n>, l, t) :- nat(n)
client_out(payload, n, client, t') :- client_in(client, payload, l, t), cycle(n, l, t), choose(_, t')




# X. Location-aware cycles?
# When the values that influence cycles influence other things too, when can they be replicated?