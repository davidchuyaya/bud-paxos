# proposer
# Syntax note: Capital = scratch (not persisted)
# Assumption: count on empty relation returns 0. Undefined if there are group-by attributes (returns null in SQL for those columns)

######################## relation definitions
# EDB
id(id) # Used in ballots, but also is proposer's physical location
acceptors(id)
proposers(id)
quorum(size)
ballotGeq(id1, num1, id2, num2) # true if num1 >= num2 or (num1 = num2 and id1 >= id2)
ballotGt(id1, num1, id2, num2) # true if num1 > num2 or (num1 = num2 and id1 > id2)
nat(n) # all natural numbers
leaderTimeout(n) # time to wait before judging leader as dead.
initBallot(n) # 0

# IDB
client_in(payload, l, t)
client_out(payload, slot, l, t)

ballot(slot, num, l, t) # Assume starts with num = 0
NewBallot(slot, num, l, t)
IsLeader(slot, l, t) # bool, has an entry for this time if we are leader
RelevantP1bs(slot, acceptorID, logSize, l, t)
CountMatchingP1bs(slot, c, l, t) # number of p1bs that have us as leader
receivedBallots(slot, id, num, l, t)
MaxReceivedBallotNum(slot, num, l, t)
MaxReceivedBallot(slot, id, num, l, t) # largest ballot seen in p1b or p2b
LatestIAmLeader(slot, arrivalTime, l, t)
LeaderExpired(slot, l, t)

RelevantP1bLogs(acceptorID, payload, slot, payloadBallotID, payloadBallotNum, l, t) # relevant = has our ballot
P1bLogFromAcceptor(acceptorID, slot, c, l, t) # count of p1b entries received from each acceptor
P1bNumAcceptorsLogReceived(slot, c, l, t) # number of acceptors whose full p1b log has arrived
canSendP2a(slot, l, t) # true once all p1b logs have been received from acceptors who sent p1bs, reset to false once we lose leader election. Reason for persisting: reconciling p1b must happen before any new slots are chosen; new slots are only chosen when this is true, so this must be set to true THE TIMESTEP AFTER all p1bs are reconciled.
P1bMatchingEntry(payload, slot, c, id, num, l, t) # how many p1bs have this payload for this slot num? Note that same payload & different ballot = treated as different. This is fine, since uncommitted entries will be resent to every acceptor with the same ballot.
P1bSlotReceived(slot, c, l, t) # how many p1bs have we received for this slot? Once we hit quorum, can make decision
P1bLargestEntryBallotNum(slot, num, l, t)
P1bLargestEntryBallot(slot, id, num, l, t) # largest ballot per slot in p1bs
P1bResentEntries(payload, slot, l, t) # entries to resend p2as for, based on uncommitted entries in p1b

proposedLog(payload, slot, l, t) # potentially uncommitted entries. Re-create on re-election 
payloads(payload, l, t) # all payloads ever received from client. On leader re-election, re-propose whatever isn't in the p1bs
MinLogHole(slot, l, t) # slot num of smallest hole in log
ChosenPayload(payload, l, t) # payload to propose in this timestep
CountMatchingP2bs(payload, slot, c, l, t) # number of p2bs per entry that still have us as leader

p1a(proposerID, slot, ballotID, ballotNum, l, t) # proposerID is the location of the proposer
p1b(acceptorID, logSize, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t) # logSize is either 0 or 1
p1bLog(acceptorID, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, l, t)
p2a(proposerID, payload, slot, ballotID, ballotNum, l, t) # proposerID is the location of the proposer
p2b(acceptorID, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t)
timeout(l, t) # Assume starts with a fact. async channel that tells us when to resend p1a
iAmLeader(slot, arrivalTime, l, t) # Assume starts with 0.
######################## end relation definitions



p1b(a, l, s, i, n, mi, mn, l, t') :- p1b(a, l, s, i, n, mi, mn, l, t), succ(t, t')
p1bLog(a, p, s, pi, pn, i, n, l, t') :- p1bLog(a, p, s, pi, pn, i, n, l, t), succ(t, t')
p2b(a, p, s, i, n, mi, mn, l, t') :- p2b(a, p, s, i, n, mi, mn, l, t), succ(t, t')
receivedBallots(s, i, n, l, t') :- receivedBallots(s, i, n, l, t), succ(t, t')
payloads(p, l, t) :- client_in(p, l, t)
payloads(p, l, t') :- payloads(p, l, t), succ(t, t')
iAmLeader(s, arrivalTime, l, t') :- iAmLeader(s, arrivalTime, l, t), succ(t, t')


######################## stable leader election
RelevantP1bs(acceptorID, slot, logSize, l, t) :- p1b(acceptorID, logSize, slot, i, num, _, _, l, t), id(i), ballot(slot, num, l, t)
CountMatchingP1bs(slot, count<acceptorID>, l, t) :- RelevantP1bs(slot, acceptorID, logSize, l, t)
receivedBallots(slot, maxBallotID, maxBallotNum, l, t) :- p1b(_, _, slot, _, _, maxBallotID, maxBallotNum, l, t)
receivedBallots(slot, maxBallotID, maxBallotNum, l, t) :- p2b(_, _, slot, _, _, _, maxBallotID, maxBallotNum, l, t)
MaxReceivedBallotNum(slot, max<num>, l, t) :- receivedBallots(slot, _, num, l, t)
MaxReceivedBallot(slot, max<id>, num, l, t) :- MaxReceivedBallotNum(slot, num, l, t), receivedBallots(slot, id, num, l, t)
IsLeader(slot, l, t) :- CountMatchingP1bs(slot, c, l, t), quorum(size), c >= size, id(i), ballot(slot, num, l, t), MaxReceivedBallot(slot, maxId, maxNum, l, t), ballotGeq(i, num, maxId, maxNum)

# send heartbeat if we're the leader
iAmLeader(slot, t', proposerID, t') :- IsLeader(slot, l, t), proposers(proposerID), id(self), self != proposerID, choose(_, t')
LatestIAmLeader(slot, max<arrivalTime>, l, t) :- iAmLeader(slot, arrivalTime, l, t)
LeaderExpired(slot, l, t) :- LatestIAmLeader(slot, arrivalTime, l, t), leaderTimeout(timeout), t - arrivalTime > timeout
# Resend p1a if we've received a larger ballot AND we waited a random amount of time (timeout) AND leader heartbeat timed out
NewBallot(slot, newNum, l, t) :- MaxReceivedBallot(slot, maxId, maxNum, l, t), id(i), ballot(slot, num, l, t), ballotGt(maxId, maxNum, i,  num), timeout(slot, l, t), LeaderExpired(slot, l, t), newNum = num + 1 
# Start sending p1a at beginning of program
NewBallot(slot, num, l, t) :- MinLogHole(slot, l, t), ¬receivedBallots(slot, _, _, l, t), initBallot(num), timeout(slot, l, t)

p1a(i, slot, i, num, a, t') :- id(i), NewBallot(slot, num, l, t), acceptors(a), choice(_, t')
ballot(slot, num, l, t') :- NewBallot(slot, num, l, t), succ(t, t')
ballot(slot, num, l, t') :- ballot(slot, num, l, t), ¬NewBallot(slot, newNum, l, t), succ(t, t')
# send timeout message with unknown arrival time
timeout(slot, l, t') :- MinLogHole(slot, l, t), choose(_, t')
timeout(slot, l, t') :- timeout(slot, l, t), choose(_, t')
######################## end stable leader election 



######################## reconcile p1b log with local log
RelevantP1bLogs(acceptorID, payload, slot, payloadBallotID, payloadBallotNum, l, t) :- p1bLog(acceptorID, payload, slot, payloadBallotID, payloadBallotNum, i, num, l, t), id(i), ballot(slot, num, l, t)

# cannot send new p2as until all p1b acceptor logs are PROCESSED; otherwise might miss pre-existing entry
P1bLogFromAcceptor(acceptorID, slot, 1, l, t) :- RelevantP1bLogs(acceptorID, _, slot, _, _, l, t)
P1bLogFromAcceptor(acceptorID, slot, 0, l, t) :- RelevantP1bs(acceptorID, slot, _, l, t), ¬RelevantP1bLogs(acceptorID, _, slot, _, _, l, t)
P1bNumAcceptorsLogReceived(slot, count<acceptorID>, l, t) :- P1bLogFromAcceptor(acceptorID, slot, receivedCount, l, t), RelevantP1bs(acceptorID, slot, logSize, l, t), receivedCount == logSize
# logs don't count as all received until NEXT TIMESTEP; all p1b resends should've happened before then. If IsLeader is false, this is reset. In the timestep after that, we propose with a new ballot, so no quorum can be reached with p1b logs, until we actually win phase 1 again & receive all logs.
canSendP2a(slot, l, t') :- P1bNumAcceptorsLogReceived(slot, c, l, t), quorum(size), c >= size, IsLeader(slot, l, t), succ(t, t')

P1bMatchingEntry(payload, slot, count<acceptorID>, payloadBallotID, payloadBallotNum, l, t) :-  RelevantP1bLogs(acceptorID, payload, slot, payloadBallotID, payloadBallotNum, l, t)
# what was committed = store in local log. Note: Don't need to worry about overwriting; it's impossible to have f+1 matching for the same slot and another payload with a higher ballot; therefore this slot must already have the same payload (maybe with a lower ballot)
proposedLog(payload, slot, l, t) :- P1bMatchingEntry(payload, slot, c, _, _, l, t), quorum(size), c >= size

# what was not committed = find max ballot, store in local log, resend 
P1bSlotReceived(slot, count<acceptorID>, l, t) :- RelevantP1bLogs(acceptorID, _, slot, _, _, l, t)
P1bLargestEntryBallotNum(slot, max<payloadBallotNum>, l, t) :- RelevantP1bLogs(_, _, slot, _, payloadBallotNum, l, t)
P1bLargestEntryBallot(slot, max<payloadBallotID>, payloadBallotNum, l, t) :- P1bLargestEntryBallotNum(slot, payloadBallotNum, l, t), RelevantP1bLogs(_, _, slot, payloadBallotID, payloadBallotNum, l, t)
# does not explicitly avoid resending committed entries, since proposedLog is negated, which means that committed entries (which are written to proposedLog in the same timestep) must be in an earlier strata and are implicitly avoided
# makes sure that p2as cannot be sent yet; otherwise resent slots might conflict. Once p2as can be sent, a new p1b log might tell us to propose a payload for the same slot we propose (in parallel) for p2a, which violates an invariant.
ResentEntries(payload, slot, l, t) :- P1bLargestEntryBallot(slot, payloadBallotID, payloadBallotNum, l, t), P1bMatchingEntry(payload, slot, _, payloadBallotID, payloadBallotNum, l, t), IsLeader(slot, l, t), P1bSlotReceived(slot, c, l, t), quorum(size), c >= size, ¬proposedLog(_, slot, l, t), ¬canSendP2a(slot, l, t)
proposedLog(payload, slot, l, t') :- ResentEntries(payload, slot, l, t), succ(t, t') # must be succ because proposedLog is negated in ResentEntries
p2a(i, payload, slot, i, num, a, t') :- ResentEntries(payload, slot, l, t), id(i), ballot(slot, num, l, t), acceptors(a), choose(_, t')
# only persist proposedLog if we're the leader. This way, when we lose election, the proposals are refreshed based on p1bs
proposedLog(p, s, l, t') :- proposedLog(p, s, l, t), IsLeader(s, l, t), succ(t, t')
######################## end reconcile p1b log with local log



######################## send p2as 
# assign a slot
MinLogHole(min<slot>, l, t) :- ¬proposedLog(_, slot, l, t), nat(slot)
ChosenPayload(choose<payload>, l, t) :- payloads(payload, l, t), ¬proposedLog(payload, _, l, t), canSendP2a(l, t)
p2a(i, payload, slot, i, num, a, t') :- ChosenPayload(payload, l, t), MinLogHole(slot, l, t), id(i), ballot(slot, num, l, t), acceptors(a), choose(_, t')
proposedLog(payload, slot, l, t') :- ChosenPayload(payload, l, t), MinLogHole(slot, l, t), succ(t, t')
######################## end send p2as 



######################## process p2bs
CountMatchingP2bs(payload, slot, count<acceptorID>, l, t) :- p2b(acceptorID, payload, slot, i, num, _, _, l, t), id(i), ballot(slot, num, l, t) # only count p2bs if the acceptor thinks we're the leader. Ensures p2bs are "up-to-date"
client_out(payload, slot, l, t) :- CountMatchingP2bs(payload, slot, c, l, t), quorum(size), c >= size
######################## end process p2bs