# acceptor

######################## relation definitions
# EDB
id(id)
ballotGeq(id1, num1, id2, num2) # true if num1 >= num2 or (num1 = num2 and id1 >= id2)

# IDB
ballots(id, num, l, t) # Assumes starts with 0,0
log(payload, slot, ballotID, ballotNum, l, t)
LogSize(size, l, t)
LogEntryMaxBallotNum(slot, ballotNum, l, t)
LogEntryMaxBallot(slot, ballotID, ballotNum, l, t)
MaxBallotNum(num, l, t)
MaxBallot(id, num, l, t)

# copied from proposer
p1a(proposerID, ballotID, ballotNum, l, t) # NOTE: not persisted
p1b(acceptorID, logSize, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t)     # NOTE: logSize necessary because p1b can't send entire log back in 1 msg
p1bLog(acceptorID, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, l, t)
p2a(proposerID, payload, slot, ballotID, ballotNum, l, t)
p2b(acceptorID, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, l, t)
######################## end relation definitions



ballots(i, n, l, t') :- ballots(i, n, l, t), succ(t, t')
log(p, slot, ballotID, ballotNum, l, t') :- log(p, slot, ballotID, ballotNum, l, t), succ(t, t')



######################## reply to p1a 
ballots(id, num, l, t) :- p1a(_, id, num, l, t)
MaxBallotNum(max<num>, l, t) :- ballots(_, num, l, t) 
MaxBallot(max<id>, num, l, t) :- MaxBallotNum(num, l, t), ballots(id, num, l, t)
LogSize(count<slot>, l, t) :- log(_, slot, _, _, l, t)
p1b(i, size, ballotID, ballotNum, maxBallotID, maxBallotNum, proposerID, t') :- p1a(proposerID, ballotID, ballotNum, l, t), id(i), LogSize(size, l, t), MaxBallot(maxBallotID, maxBallotNum, l, t), choice(_, t')

LogEntryMaxBallotNum(slot, max<ballotNum>, l, t) :- log(_, slot, _, ballotNum, l, t)
LogEntryMaxBallot(slot, max<ballotID>, ballotNum, l, t) :- LogEntryMaxBallotNum(slot, ballotNum, l, t), log(_, slot, ballotID, ballotNum, l, t)

# send back entire log 
p1bLog(i, payload, slot, payloadBallotID, payloadBallotNum, ballotID, ballotNum, proposerID, t') :- id(i), log(payload, slot, payloadBallotID, payloadBallotNum, l, t), LogEntryMaxBallot(slot, payloadBallotID, payloadBallotNum, l, t), p1a(proposerID, ballotID, ballotNum, l, t), choice(_, t')
######################## end reply to p1a 



######################## reply to p2a
ballots(id, num, l, t) :- p2a(_, _, _, id, num, l, t) 
# Any rule that uses MaxBallot is guaranteed to only run once all ballots have been processed
log(payload, slot, ballotID, ballotNum, l, t) :- p2a(_, payload, slot, ballotID, ballotNum, l, t), MaxBallot(maxID, maxNum, l, t), ballotGeq(ballotID, ballotNum, maxID, maxNum)
p2b(i, payload, slot, ballotID, ballotNum, maxBallotID, maxBallotNum, proposerID, t') :- p2a(proposerID, payload, slot, ballotID, ballotNum, l, t), id(i), MaxBallot(maxBallotID, maxBallotNum, l, t), choice(_, t')
######################## end reply to p2a