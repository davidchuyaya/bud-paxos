// TODO: [x] create viewChangeMessageSetByView to prevent relying on a magic relation that doesnt exist (contains)
// TODO: [x] new view log (verifying the O set)
// TODO: [x] add liveness view change multicast pseudocode
// TODO: [x] implement view-transition true/false state to prevent accepting consensus messages during view changes
// TODO: [x] define channel to send commands to execution
// TODO: [x] define channel to take in results of executing commands (to send to client)
// TODO: [x] define channel to take in copy of state machine state (to send for checkpointing)
// TODO: [x] create checkpointing logic
// TODO: account for watermarks in log messages
// TODO: create logic to find missing client messages + checkpoint states
// TODO: comments
// TODO: remove all parentheses in outboxes
// TODO: remove all ls and ts to adhere to shadaj syntax
// TODO: find which relations are garbage collected and leave question marks for those that you're unsure about (like watermarks)
// TODO: how to garbage collect with checkpoints? oooh the condition in msgLog that requires seqNum >= h might have a double use
// TODO: move in david's critical path code
// TODO: client implementation (if no response from primary broadcast to all nodes)
// ∈
########## EDBs

# EDBs provided by the system
ZERO(n)
next(t, t')
publicKeyStore(pk, l)
privateKeyStore(sk, l)
verifySignature(pk, msg, sig)
signMsg(sk, msg, sig)
digest(msg, d) # d is the digest of msg
contains(set, elem) # set contains elem
replicas(l) # one row per replica l

# EDBs created for this protocol
FAILURES(f)
NO_OP(op)
WATERMARK_WIDTH(k)
CHECKPOINT_INTERVAL(k)
REQUEST_EXPIRATION(delta)
NEW_VIEW_EXPIRATION(delta)
INITIAL_STATE_DIGEST(d)
viewPrimary(v, l)

########## end EDBs



########## IDBs

STATE_MACHINE(l') # the replica's own state machine

########## end IDBs



########## client requests

requestVerifiedIn((o, clientTimestamp, l'), sig, l', l, t) :-
    requestIn((o, clientTimestamp, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (o, clientTimestamp, l'), sig)

// ASK?: say the client sends a request to a byzantine primary, who ignores it; the client then broadcasts this request to all replicas, who start a timer upon receiving it; say the timer expires, since only the primary can kick off the consensus process and this request hasnt satisfied the prepared predicate, is it just dropped/ignored when replicas move into the next view? does the new primary automatically kick off the consensus process with all "orphaned" requests?
requestLog(o, clientTimestamp, l', sig, l, t') :-
    requestVerifiedIn((o, clientTimestamp, l'), sig, l', l, t), # contacted directly
    ¬attemptingViewChange(_, l, t),
    ¬requestLog(o, clientTimestamp, l', sig, l, t), # no duplicates
    next(t, t')

requestLog(o, clientTimestamp, l', sig, l, t') :-
    preprepareLog(_, _, _, o, clientTimestamp, l', sig, l, t), # taken from a preprepare
    ¬requestLog(o, clientTimestamp, l', sig, l, t), # no duplicates
    next(t, t')

requestLog(o, clientTimestamp, l', sig, l, t') :-
    requestLog(o, clientTimestamp, l', sig, l, t),
    next(t, t')

########## end client requests



########## critical path

preprepareVerifiedIn((v, n, d), sig, (o, clientTimestamp, clientLocation), clientSig, l', l, t) :-
    preprepareIn((v, n, d), sig, (o, clientTimestamp, clientLocation), l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v, n, d), sig)
    publicKeyStore(pk, clientLocation),
    verifySignature(pk, (o, clientTimestamp, clientLocation), clientSig)

preprepareLog(v, n, d, sig, o, clientTimestamp, clientLocation, clientSig, l, t) :-
    preprepareVerifiedIn((v, n, d), sig, (o, clientTimestamp, clientLocation), clientSig, l', l, t),
    ¬attemptingViewChange(_, l, t),
    viewPrimary(v, l'),
    digest(o, d),
    currentView(v, l, t),
    ¬preprepareLog(v, n, d', _, _, _, _, _, l, t),
    d != d',
    lowWatermark(h, l, t),
    h < n,
    WATERMARK_WIDTH(k),
    n < h + k

prepareVerifiedIn((v, n, d, l'), sig, l', l, t) :-
    prepareIn((v, n, d, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v, n, d, l'), sig)

prepareLog(v, n, d, l', sig, l, t) :-
    prepareVerifiedIn((v, n, d, l'), sig, l', l, t),
    ¬attemptingViewChange(_, l, t),
    currentView(v, l, t),
    lowWatermark(h, l, t),
    h < n,
    WATERMARK_WIDTH(k),
    n < h + k

########## end critical path



########## message commit

prepareCertSize(v, n, d, count<l'>, l, t) :-
    prepareLog(v, n, d, l', _, l, t)

prepared(m, v, n, l, t) :-
    preprepareLog(v, n, d, _, _, _, _, _, l, t),
    prepareCertSize(v, n, d, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

commitOutbox((v, n, d, l), l, t) :-
    prepared(m, v, n, l, t),
    digest(m, d)

commitSent((v, n, d, l), l, t') :-
    commitOutbox((v, n, d, l), l, t),
    next(t, t')

commitSent((v, n, d, l), l, t') :-
    commitSent((v, n, d, l), l, t),
    next(t, t')

commitIn((v, n, d, l), sig, l, l', t')@async :-
    commitOutbox((v, n, d, l), l, t),
    ¬commitSent((v, n, d, l), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (v, n, d, l), sig),
    replicas(l')

commitVerifiedIn((v, n, d, l'), sig, l', l, t) :-
    commitIn((v, n, d, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v, n, d, l'), sig)

commitLog(v, n, d, l', sig, l, t) :-
    ¬attemptingViewChange(_, l, t),
    ... # accepted commits

########## end message commit



########## command execution + client reply

committedLocal((o, clientTimestamp, l'), v, n, l, t) :-
    ...

// ASK: do we execute a request m if committedLocal(m, v, n) is true for SOME v or only the CURRENT v?
// ASK: since we only execute a request if committedLocal is true and we've executed all requests with seq nums before it; if it's the latter and we 1. satisfy committedLocal(m, v, n) but don't execute m because we're waiting on preceding requests to be executed, 2. complete a view change into v', 3. execute all requests preceding m, can we only execute m once committedLocal(m, v', n) is true (this implies that we redo consensus for it once the view change completes)?
// ASK: if so, why do we have to redo consensus for messages satisfying committedLocal in the previous view if the only problem is that we haven't executed them? would it ever be possible for another message (or a no-op) to take over its sequence number? if not, why do we have to wait if we're guaranteed that only this message will ever be committed in this seq num?
// ASK: to me, once committedLocal is true, i know nobody else will ever have a problem with me executing m at seq n; this agreement doesn't seem to hinge on my execution history of previous messages (it honestly seems independent of any other seq num in general); would a replica ever need to know my past execution history before making this promise? it doesn't seem like we ever share this information via consensus
// ASK: this is basically asking if i can assume committedLocal(m, v, n) for some v => "nothing other than m will ever be executed at seq num n" and if "nothing other than m will ever be executed at seq num n" => "you can execute this as soon as the state machine allows it"
// ASK: i guess this is a big roundabout way of asking if the queue to execute commands is independent from consensus after messages have been added, aka messages will never be removed from the queue for safety purposes
// ans: seems like as soon as committedLocal is satisfied it can be scheduled for execution no matter what else happens, as soon as the state machine is ready you can just go for it regardless of where the consensus nodes are at
executeCommandOutbox((o, n), l, t) :-
    committedLocal((o, _, _), _, n, l, t),
    latestExecutedCommandSeqNum(n'),
    n = n' + 1

executeCommandSent((o, n), l, t') :-
    executeCommandOutbox((o, n), l, t),
    next(t, t')

executeCommandSent((o, n), l, t') :-
    executeCommandSent((o, n), l, t),
    next(t, t')

// ASK?: do we need to sign messages being "sent" to the state machine (and likewise do we expect signatures on their replies)?
executeCommandIn((o, n), sig, l, l', t')@async :-
    executeCommandOutbox((o, n), l, t),
    ¬executeCommandSent((o, n), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (o, n), sig),
    STATE_MACHINE(l')

executeCommandReplyIn((o, n, res), sig, l, l', t)@async :-
    ... # reply sent via input channel

executeCommandReplyVerifiedIn((o, n, res), sig, l', l, t) :-
    executeCommandReplyIn((o, n, res), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (o, n, res), sig)

// ASK?: sanity check, is it okay for us to still reply to clients while in a view change? say a message satisfied committedLocal but by the time it's actuall executed we're in the middle of a view change
executeCommandReplyLog(o, n, res, sig, l, t) :-
    executeCommandReplyVerifiedIn((o, n, res), sig, _, l, t)

latestExecutedCommandSeqNum(max<n>, l, t) :-
    executeCommandReplyLog(_, n, _, _, l, t)

replyOutbox((v, clientTimestamp, l', l, res), l, t) :-
    executeCommandReplyLog(o, n, res, _, l, t),
    currentView(v, l, t), // ASK?: do we want the view that the message was committed in or the view that we replied in?
    committedLocal((o, clientTimestamp, l'), _, n, l, t) // NOTE: if we want the view the message was committed in use the view here

replySent((v, clientTimestamp, l', l, res), l, t') :-
    replyOutbox((v, clientTimestamp, l', l, res), l, t),
    next(t, t')

replySent((v, clientTimestamp, l', l, res), l, t') :-
    replySent((v, clientTimestamp, l', l, res), l, t),
    next(t, t')

replyIn((v, clientTimestamp, l', l, res), sig, l, l', t')@async :-
    replyOutbox((v, clientTimestamp, l', l, res), l, t),
    ¬replySent((v, clientTimestamp, l', l, res), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (v, clientTimestamp, l', l, res), sig)

########## end command execution + client reply



########## checkpointing

// ASK?: say we snapshot every 10; what happens if we get the replies from executing two commands at seq num 10 and 11 concurrently (we get replies from the state machine in the same timestep), and thus the state machine state only reflects the state after seq num 11 and not 10? do we skip making a checkpoint? should we have the state machine reply with the entire state for each reply on a checkpoint seq num, since we can't guarantee that replies from the state machine are staggered into distinct timesteps?
# take a snapshot every CHECKPOINT_INTERVAL
snapshotRequestOutbox((n), l, t) :-
    # seq num only acts as request id, since we can only snapshot in the present
    latestExecutedCommandSeqNum(n, l, t), // NOTE: assumes that n will not be incremented more than once per timestep, aka replies from the state machine will not arrive concurrently
    CHECKPOINT_INTERVAL(k),
    n % k = 0

snapshotRequestOutbox((n), l, t') :-
    snapshotRequestOutbox((n), l, t),
    next(t, t')

snapshotRequestSent((n), l, t') :-
    snapshotRequestSent((n), l, t),
    sent(t, t')

checkpointIn((n), sig, l, l', t')@async :-
    snapshotRequestOutbox((n), l', t),
    ¬snapshotRequestSent((n), l', t),
    privateKeyStore(sk, l),
    signMsg(sk, (n), sig),
    replicas(l')

snapshotIn((n, s), sig, l, l', t)@async :-
    ... # reply sent via input channel

snapshotVerifiedIn((n, s), sig, l', l, t) :-
    snapshotIn((n, s), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (n, s), sig)

snapshotLog(n, s, sig, l, t) :-
    snapshotVerifiedIn((n, s), sig, _, l, t)

# broadcast checkpoint messages whenever a snapshot comes in, we defer the timing logic of snapshots to snapshotRequest
checkpointOutbox((n, d, l), l, t) :-
    snapshotLog(n, s, _, l, t),
    digest(s, d)

checkpointSent((n, d, l), l, t') :-
    checkpointOutbox((n, d, l), l, t),
    next(t, t')

checkpointSent((n, d, l), l, t') :-
    checkpointSent((n, d, l), l, t),
    sent(t, t')

checkpointIn((n, d, l), sig, l, l', t')@async :-
    checkpointOutbox((n, d, l), l', t),
    ¬checkpointSent((n, d, l), l', t),
    privateKeyStore(sk, l),
    signMsg(sk, (n, d, l), sig),
    replicas(l')

checkpointVerifiedIn((n, d, l'), sig, l', l, t) :-
    checkpointIn((n, d, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (n, d, l'), sig)

// ASK?: planning on only accepting one checkpoint message from any (n, l') pair, are there no requirements for accepting checkpoint messages?
checkpointLog(n, d, l', sig, l, t) :-
    checkpointVerifiedIn((n, d, l'), sig, l', l, t),
    ¬checkpointLog(n, d', l', sig, l, t), # we only accept the first checkpoint message from any (n, l') pair
    d != d'

checkpointCertSize(n, d, count<l'>, l, t) :-
    checkpointLog(n, d, l', _, l, t)

stableCheckpoint(n, d, l, t) :-
    checkpointCertSize(n, d, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# initialize a blank checkpoint at -1 for watermark purposes (seq nums are zero-indexed, and checkpoints at a seq num represent the state after the seq number has been executed)
stableCheckpoint(n, d, l, t) :-
    ZERO(zero),
    n = zero - 1,
    INITIAL_STATE(d)

lowWatermark(h, l, t) :-
    lastStableCheckpoint(h, l, t)

########## end checkpointing



########## view change triggers

pendingRequests((o, clientTimestamp, c), l, t) :-
    requestLog(o, clientTimestamp, c, _, l, t),
    // TODO: committedLocal is not technically correct, we only stop the timer once we've executed the request (in practice, once we've received the result of executing the request)
    // NOTE: okay it seems like it's fine, since if it's committedLocal we know it'll be executed eventually so we can treat it as completed the consensus process
    ¬committedLocal((o, clientTimestamp, c), _, _, l, t)

requestCreatedTimestamps((o, clientTimestamp, c), t, l, t') :-
    requestLog(o, clientTimestamp, c, _, l, t),
    ¬requestCreatedTimestamps((o, clientTimestamp, c), _, l, t)
    next(t, t')

requestCreatedTimestamps((o, clientTimestamp, c), timestamp, l, t') :-
    requestCreatedTimestamps((o, clientTimestamp, c), timestamp, l, t),
    next(t, t')

earliestPendingRequestCreatedTimestamp(min<timestamp>, l, t) :-
    pendingRequests(msg, l, t),
    requestCreatedTimestamps(msg, timestamp, l, t)

committedTimestamps((o, clientTimestamp, c), timestamp, l, t) :-
    ...

latestCommittedTimestamp(max<timestamp>, l, t) :-
    committedTimestamps(_, timestamp, l, t)

latestCommittedAndEarliestPendingTimestamps(timestamp, l, t) :-
    earliestPendingRequestCreatedTimestamp(timestamp, l, t)

latestCommittedAndEarliestPendingTimestamps(timestamp, l, t) :-
    latestCommittedTimestamp(timestamp, l, t)

# if there are pending requests: max(latest committed + buffer, earliest pending + buffer), otherwise infinity
requestExpiredViewChangeTimer(v', max<cutoff>, l, t) :-
    pendingRequests(_, l, t), # must have a currently pending request
    currentView(v, l, t),
    v' = v + 1, # will attempt view change for v + 1
    ¬viewChangeSent((v', _, _, _, _), l, t), # not already attempting a view change for v'; not using attemptingViewChange because that includes the timestep that the view-change is sent and negating that would cause a negation cycle
    latestCommittedAndEarliestPendingTimestamps(timestamp, l, t), # find max(latest committed + buffer, earliest pending + buffer)
    REQUEST_EXPIRATION(delta),
    cutoff = timestamp + delta # add buffer

# setup for a timer for the time between receiving 2f + 1 view-change messages but before receiving a corresponding new-view message
awaitingNewView(v', l, t) :-
    newViewReady(v', l, t),
    ¬newViewLog(v', _, _, _, _, l, t)

# start timer once receiving 2f + 1 view-changes for v', stop once new-view message for v' is received (or timer elapses)
newViewExpiredViewChangeTimer(v', cutoff, l, t) :-
    awaitingNewView(v', l, t), # waiting for a new-view for v'
    currentView(v, l, t),
    v' > v, # only attempt view change for views above ours
    ¬newViewExpiredViewChangeTimerElapsed(v, v', l, t), # no timers that have already elapsed
    numNewViewExpiredViewChangeTimersElapsed(v, x, l, t),
    NEW_VIEW_EXPIRATION(delta),
    cutoff = delta * 2 ** x # double the timer each consecutive time it's elapsed in the same view

newViewExpiredViewChangeTimerElapsed(v, v', l, t') :-
    currentView(v, l, t),
    newViewExpiredViewChangeTimer(v', cutoff, l, t),
    t >= cutoff,
    next(t, t')

newViewExpiredViewChangeTimerElapsed(v, v', l, t') :-
    newViewExpiredViewChangeTimerElapsed(v, v', l, t),
    next(t, t')

numNewViewExpiredViewChangeTimersElapsed(v, count<v'>, l, t) :-
    newViewExpiredViewChangeTimerElapsed(v, v', l, t)

# view change triggered by f + 1 view-change messages with higher views
numHigherViewChangeMessageSenders(count<l'>, l, t) :-
    currentView(v, l, t),
    viewChangeLog(v', _, _, _, l', _, l, t),
    v' > v

# take the minimum out of higher view-change messages
minHigherViewChangeMessage(min<v'>, l, t) :-
    currentView(v, l, t),
    viewChangeLog(v', _, _, _, l', _, l, t),
    v' > v

higherViewChangeTimer(v', t, l, t) :-
    numHigherViewChangeMessageSenders(x, l, t),
    FAILURES(f),
    x >= f + 1,
    minHigherViewChangeMessage(v', l, t),
    ¬higherViewChangeTimerElapsed(v', l, t)

# the timer goes "off" for one timestep 
higherViewChangeTimerElapsed(v', l, t) :-
    higherViewChangeTimer(v', cutoff, l, t),
    t >= cutoff,
    next(t, t')

higherViewChangeTimerElapsed(v', l, t') :-
    higherViewChangeTimerElapsed(v', l, t),
    next(t, t')

aggregateViewChangeTimer(v', cutoff, l, t) :-
    requestExpiredViewChangeTimer(v', cutoff, l, t)

aggregateViewChangeTimer(v', cutoff, l, t) :-
    newViewExpiredViewChangeTimer(v', cutoff, l, t)

aggregateViewChangeTimer(v', cutoff, l, t) :-
    higherViewChangeTimer(v', cutoff, l, t)

# we only care about at most one timer at a time (the closest one)
viewChangeTimer(v', min<cutoff>, l, t) :-
    aggregateViewChangeTimer(v', cutoff, l, t)

########## end view change triggers



########## creating view-change + new-view messages

stableCheckpointProof(n, d, *((n, d, l'), sig), l, t) :-
    stableCheckpoint(n, d, l, t),
    checkpointLog(n, d, l', sig, l, t)

lastStableCheckpoint(max<n>, l, t) :-
    stableCheckpoint(n, _, l, t)

preparedProof(m, v, n, ((v, n, d), preprepSig), *((v, n, d, l'), sig), l, t) :-
    prepared(m, v, n, l, t),
    preprepareLog(v, n, d, preprepSig, _, _, _, _, l, t),
    prepareLog(v, n, d, l', sig, l, t)

// filter out earlier for performance
// only send highest view, can delete messages under that
uncheckpointedPreparedProofs(*(preprep, prepareCert), l, t) :-
    preparedProof(_, _, n, preprep, prepareCert, l, t),
    lastStableCheckpoint(chkptSeqNum, l, t),
    n > chkptSeqNum

# to allow us to stop accepting consensus messages when a view change is in progress; includes the timestep the view-change message is sent out to prevent the concurrent acceptance of consensus messages
attemptingViewChange(v', l, t) :-
    viewChangeOutbox((v', _, _, _, _), l, t)

# only attempt view changes into views above the current view
attemptingViewChange(v', l, t') :-
    attemptingViewChange(v', l, t),
    currentView(v, l, t),
    v' > v,
    next(t, t')

// add negation to do exactly-once semantics and avoid spam
viewChangeOutbox((v', n, C, P, l), l, t) :-
    viewChangeTimer(v' cutoff, l, t),
    t >= cutoff,
    currentView(v, l, t),
    v' > v,
    lastStableCheckpoint(n, l, t),
    stableCheckpointProof(n, _, C, l, t),
    uncheckpointedPreparedProofs(P, l, t)

viewChangeSent((v', n, C, P, l), l, t') :-
    viewChangeOutbox((v', n, C, P, l), l, t),
    next(t, t')

viewChangeSent((v', n, C, P, l), l, t') :-
    viewChangeSent((v', n, C, P, l), l, t),
    next(t, t')

// garbage collect by not persisting (:+)
// - :+ persists stuff into the *next* timestamp
// - :- adds stuff within the same tick and nothing else
// - .persist r1 persists everything in r1 for each tick (makes it monotonic)
// ASK: why broadcast view changes to all replicas if the primary sends V anyway? will replicas ever use received view changes that aren't in V? ans: yes, for liveness (see paper)
viewChangeIn((v', n, C, P, l), sig, l, l', t')@async :-
    viewChangeOutbox((v', n, C, P, l), l, t),
    ¬viewChangeSent((v', n, C, P, l), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (v', n, C, P, l), sig),
    replicas(l')

// TODO: VIEW-CHANGE TIMER, MISC. LOG CONDITIONS
// TODO: create sets as soon as possible and make sure they don't explode cross products
viewChangeVerifiedIn((v, n, C, P, l'), sig, l', l, t) :-
    viewChangeIn((v, n, C, P, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v, n, C, P, l'), sig)

viewChangeLog(v, n, C, P, l', sig, l, t) :-
    ... # accepted view-changes
    // check i am the supposed primary of the new view? no, new primary will do check before sending out new-view messages

viewChangeCertSize(v, count<l'>, l, t) :-
    viewChangeLog(v, _, _, _, l', _, l, t)

newViewReady(v, l, t) :-
    viewChangeCertSize(v, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

viewChangeMessages(v, *((v, n, C, P, l'), sig), l, t) :-
    viewChangeLog(v, n, C, P, l', sig, l, t)

# if the primary, will create myself
# if not the primary case exists further below
viewChangeMessageSetByView(v, viewChangeMsgSet, l, t) :-
    viewPrimary(v, l),
    viewChangeMessages(v, viewChangeMsgSet, l, t)

# viewChangeMsgSet => *((v, n, C, P, l'), sig)
# all "FromViewChangeSet" assumes viewChangeMsgSet is well-formed
latestStableCheckpointSeqNumFromViewChangeSet(viewChangeMsgSet, max<chkptSeqNum>, l, t) :-
    viewChangeMessageSetByView(_, viewChangeMsgSet, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((chkptSeqNum, _, _), _))

# min-s
latestPrepareSeqNumFromViewChangeSet(viewChangeMsgSet, max<prepSeqNum>, l, t) :-
    viewChangeMessageSetByView(_, viewChangeMsgSet, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (((_, prepSeqNum, _), _), _))

# max-s
highestPreparedProofViewBySeqNumFromViewChangeSet(viewChangeMsgSet, n, max<msgView>, l, t) :-
    viewChangeMessageSetByView(_, viewChangeMsgSet, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (((msgView, n, _), _), _))

# there is an operation with seq number n in P
highestViewPreparedMessageDigestBySeqNumFromViewChangeSet(viewChangeMsgSet, n, d, l, t) :-
    highestPreparedProofViewBySeqNumFromViewChangeSet(viewChangeMsgSet, n, highestProofView, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (((highestProofView, n, d), _), _)), # should only have one unique value of d

# no operation exists for seq number min-s < n <= max-s in P
emptyBoundedSeqNumsFromViewChangeSet(viewChangeMsgSet, n, l, t) :-
    latestStableCheckpointSeqNumFromViewChangeSet(viewChangeMsgSet, minSeqNum, l, t),
    latestPrepareSeqNumFromViewChangeSet(viewChangeMsgSet, maxSeqNum, l, t),
    minSeqNum < n <= maxSeqNum,
    ¬highestViewPreparedMessageDigestBySeqNumFromViewChangeSet(viewChangeMsgSet, n, _, l, t)

// ASK: is the set operator by rule or by table? this also applies to aggregates in general; ans: by rule
// in other words, does

// a(*u) :-
//     f(u)

// a(*v) :-
//     g(v)

// equal?

// b(u) :-
//     f(u)

// b(v) :-
//     g(v)

// a(*w) :-
//     b(w)

// or does the first example instead create two different rows, one for both f and g?

// ASK: can i even do? in other words, does datalog type-check at all? side question, what about tuples? ans: yes assume things are strongly type checked

// a(*u) :-
//     f(u)

// a(v) :-
//     g(v)

// why it is relevant: a = O set, f(u) = a message exists in the P set for seq number n, g(v) = no message exists in the P set for seq number n (and therefore we need a no-op)

# first case for an element in the O set (the message in P with the highest view under the seq number n)
newViewPreparedMessagesFromViewChangeSet(viewChangeMsgSet, ((v', n, d), sig), l, t) :-
    contains(viewChangeMsgSet, ((v', _, _, _, _), _)), # should only be one v'
    highestViewPreparedMessageDigestBySeqNumFromViewChangeSet(viewChangeMsgSet, n, d, l, t),
    latestStableCheckpointSeqNumFromViewChangeSet(viewChangeMsgSet, minSeqNum, l, t),
    latestPrepareSeqNumFromViewChangeSet(viewChangeMsgSet, maxSeqNum, l, t),
    minSeqNum < n <= maxSeqNum, // could bound seq nums earlier for performance
    privateKeyStore(sk, l),
    signMsg(sk, (v', n, d), sig)

# second case for an element in the O set (no message in P, no-op)
newViewPreparedMessagesFromViewChangeSet(viewChangeMsgSet, ((v', n, d), sig), l, t) :-
    contains(viewChangeMsgSet, ((v', _, _, _, _), _)), # should only be one v'
    emptySeqNumsFromViewChangeSet(viewChangeMsgSet, n, l, t),
    NO_OP(op),
    digest(op, d), // could just save the no-op digest directly for performance
    privateKeyStore(sk, l),
    signMsg(sk, (v', n, d), sig)

# combining both cases into the O set
newViewPreparedSetFromViewChangeSet(viewChangeMsgSet, *((v', n, d), sig), l, t) :-
    newViewPreparedMessagesFromViewChangeSet(viewChangeMsgSet, ((v', n, d), sig), l, t)

# new-view messages from other primaries are mixed with those meant to be sent by us, but we only send those for views in which we're the primary
newViewOutbox((v', viewChangeMsgSet, O), l, t) :-
    currentView(v, l, t),
    v' = v + 1,
    viewPrimary(v', l),
    newViewReady(v', l, t),
    viewChangeMessages(v', viewChangeMsgSet, l, t),
    newViewPreparedSetFromViewChangeSet(viewChangeMsgSet, O, l, t)

newViewSent((v', viewChangeMsgSet, O), l, t') :-
    newViewOutbox((v', viewChangeMsgSet, O), l, t),
    next(t, t')

newViewSent((v', viewChangeMsgSet, O), l, t') :-
    newViewSent((v', viewChangeMsgSet, O), l, t),
    next(t, t')

newViewIn((v', viewChangeMsgSet, O), sig, l, l', t')@async :-
    newViewOutbox((v', viewChangeMsgSet, O), l, t),
    ¬newViewSent((v', viewChangeMsgSet, O), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (v', viewChangeMsgSet, O), sig),
    replicas(l')

########## end creating view-change + new-view messages



########## verifying new-view messages

newViewVerifiedIn((v', viewChangeMsgSet, O), sig, l', l, t) :-
    newViewIn((v', viewChangeMsgSet, O), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v', viewChangeMsgSet, O), sig)

# new-view viewChangeMsgSet well formed conditions:
# - [1] at least v_n >= 2f + 1 view-change messages
# - [1] exactly v_n distinct l' values
// TODO: change to eq/dont eq syntax
# - [2] min v' in viewChangeMsgSet equals v' in the new-view
# - [2] max v' in viewChangeMsgSet equals v' in the new-view
# - [3] all view-change signatures work according to their l'
# - [4] at least c_n >= 2f + 1 checkpoint messages in C
# - [4] exactly c_n distinct l' values
# - [5] min n in C equals the n in the view-change message
# - [5] max n in C equals the n in the view-change message
# - [6] min d in C equals max d in C
# - [7] all checkpoint signatures work according to their l'
# - [8] each (preprep, prepCert) in P:
#     - [8a] at least p_n >= 2f + 1 prepare messages
#     - [8a] exactly p_n distinct l' values
#     - [8b] min v in prepCert equals v in preprep
#     - [8b] max v in prepCert equals v in preprep
#     - [8c] min n in prepCert equals n in preprep
#     - [8c] max n in prepCert equals n in preprep
#     - [8d] min d in prepCert equals d in preprep
#     - [8d] max d in prepCert equals d in preprep
#     - [8e] all prepCert signatures work according to their l'
#     - [8f] the preprep signature works according to the primary of v

newViewWellFormedIn((v', viewChangeMsgSet, O), sig, l', l, t) :-
    newViewVerifiedIn((v', viewChangeMsgSet, O), sig, l', l, t),
    viewChangeMsgSetMeetsMinimumSize(viewChangeMsgSet, l, t),
    viewChangeMsgSetParticipantsDistinct(viewChangeMsgSet, l, t),
    viewChangeMsgSetViewsMatch(viewChangeMsgSet, l, t),
    viewChangeMsgSetSignaturesValid(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofMeetsMinimumSize(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofParticipantsDistinct(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofSeqNumsMatch(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofDigestsMatch(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofSignaturesValid(viewChangeMsgSet, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofsWellFormed(viewChangeMsgSet, l, t)

# viewChangeMsgSet well formed condition [1]
viewChangeMsgSetSize(viewChangeMsgSet, count<l'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, _, l'), _))

viewChangeMsgSetParticipantSet(viewChangeMsgSet, *l', l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, _, l'), _))

viewChangeMsgSetNumDistinctParticipants(viewChangeMsgSet, count<l'>, l, t) :-
    viewChangeMsgSetParticipantSet(viewChangeMsgSet, participantSet, l, t),
    contains(participantSet, l')

# at least 2f + 1 distinct l' in viewChangeMsgSet
viewChangeMsgSetMeetsMinimumSize(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetNumDistinctParticipants(viewChangeMsgSet, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# no duplicate l' in viewChangeMsgSet
viewChangeMsgSetParticipantsDistinct(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetSize(viewChangeMsgSet, x, l, t),
    viewChangeMsgSetNumDistinctParticipants(viewChangeMsgSet, x, l, t)

# viewChangeMsgSet well formed condition [2]
viewChangeMsgSetMinView(viewChangeMsgSet, min<v'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((v', _, _, _, _), _))

viewChangeMsgSetMaxView(viewChangeMsgSet, max<v'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((v', _, _, _, _), _))

viewChangeMsgSetViewsMatch(viewChangeMsgSet, l, t) :-
    newViewVerifiedIn((v', viewChangeMsgSet, _), _, _, l, t),
    viewChangeMsgSetMinView(viewChangeMsgSet, v', l, t),
    viewChangeMsgSetMaxView(viewChangeMsgSet, v', l, t)

# viewChangeMsgSet well formed condition [3]
viewChangeMsgSetNumValidSignatures(viewChangeMsgSet, count<sig>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((v', n, C, P, l'), sig)),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v', n, C, P, l'), sig)

viewChangeMsgSetSignaturesValid(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetNumValidSignatures(viewChangeMsgSet, numSig, l, t),
    viewChangeMsgSetSize(viewChangeMsgSet, numSig, l, t)

# viewChangeMsgSet well formed condition [4]
viewChangeMsgSetStableCheckpointProofSize(viewChangeMsgSet, count<l'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((_, _, l'), _))

viewChangeMsgSetStableCheckpointProofParticipantSet(viewChangeMsgSet, l*, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((_, _, l'), _))

viewChangeMsgSetStableCheckpointProofNumDistinctParticipants(viewChangeMsgSet, count<l'>, l, t) :-
    viewChangeMsgSetStableCheckpointProofParticipantSet(viewChangeMsgSet, participantSet, l, t),
    contains(participantSet, l')

# at least 2f + 1 distinct l' in viewChangeMsgSet's C set
viewChangeMsgSetStableCheckpointProofMeetsMinimumSize(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetStableCheckpointProofNumDistinctParticipants(viewChangeMsgSet, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# no duplicate l' in viewChangeMsgSet's C set
viewChangeMsgSetStableCheckpointProofParticipantsDistinct(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetStableCheckpointProofSize(viewChangeMsgSet, x, l, t),
    viewChangeMsgSetStableCheckpointProofNumDistinctParticipants(viewChangeMsgSet, x, l, t)

# viewChangeMsgSet well formed condition [5]
viewChangeMsgSetStableCheckpointProofMinSeqNum(viewChangeMsgSet, min<n>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((n, _, _), _))

viewChangeMsgSetStableCheckpointProofMaxSeqNum(viewChangeMsgSet, max<n>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((n, _, _), _))

viewChangeMsgSetStableCheckpointProofSeqNumsMatch(viewChangeMsgSet, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, n, _, _, _), _)),
    viewChangeMsgSetStableCheckpointProofMinSeqNum(viewChangeMsgSet, n, l, t),
    viewChangeMsgSetStableCheckpointProofMaxSeqNum(viewChangeMsgSet, n, l, t)

# viewChangeMsgSet well formed condition [6]
viewChangeMsgSetStableCheckpointProofMinDigest(viewChangeMsgSet, min<d>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((_, d, _), _))

viewChangeMsgSetStableCheckpointProofMaxDigest(viewChangeMsgSet, max<d>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((_, d, _), _))

viewChangeMsgSetStableCheckpointProofDigestsMatch(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetStableCheckpointProofMinDigest(viewChangeMsgSet, d, l, t),
    viewChangeMsgSetStableCheckpointProofMaxDigest(viewChangeMsgSet, d, l, t)

# viewChangeMsgSet well formed condition [7]
viewChangeMsgSetStableCheckpointProofNumValidSignatures(viewChangeMsgSet, count<sig>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((n, d, l'), sig)),
    publicKeyStore(pk, l'),
    verifySignature(pk, (n, d, l'), sig)

viewChangeMsgSetStableCheckpointProofSignaturesValid(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetStableCheckpointProofNumValidSignatures(viewChangeMsgSet, numSig, l, t),
    viewChangeMsgSetStableCheckpointProofSize(viewChangeMsgSet, numSig, l, t)

# viewChangeMsgSet well formed condition [8]
viewChangeMsgSetUncheckpointedPreparedProofs(viewChangeMsgSet, *(preprep, prepareCert), l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert))

viewChangeMsgSetUncheckpointedValidPreparedProofs(viewChangeMsgSet, *(preprep, prepareCert), l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    viewChangeMsgSetUncheckpointedPreparedProofMeetsMinimumSize(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofParticipantsDistinct(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofViewsMatch(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofSeqNumsMatch(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofDigestsMatch(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofSignaturesValid(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofPreprepareSignatureValid(viewChangeMsgSet, (preprep, prepareCert), l, t)

viewChangeMsgSetUncheckpointedPreparedProofsWellFormed(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofs(viewChangeMsgSet, P, l, t),
    viewChangeMsgSetUncheckpointedValidPreparedProofs(viewChangeMsgSet, P, l, t)

# viewChangeMsgSet well formed condition [8a]
viewChangeMsgSetUncheckpointedPreparedProofSize(viewChangeMsgSet, (preprep, prepareCert), count<l'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, _, _, l'), _))

viewChangeMsgSetUncheckpointedPreparedProofParticipantSet(viewChangeMsgSet, (preprep, prepareCert), *l', l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, _, _, l'), _))

viewChangeMsgSetUncheckpointedPreparedProofNumDistinctParticipants(viewChangeMsgSet, (preprep, prepareCert), count<l'>, l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofParticipantSet(viewChangeMsgSet, (preprep, prepareCert), participantSet, l, t),
    contains(participantSet, l')

# at least 2f + 1 distinct l' in the uncheckpointed prepared proof
viewChangeMsgSetUncheckpointedPreparedProofMeetsMinimumSize(viewChangeMsgSet, (preprep, prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofNumDistinctParticipants(viewChangeMsgSet, (preprep, prepareCert), certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# no duplicate l' in the uncheckpointed prepared proof
viewChangeMsgSetUncheckpointedPreparedProofParticipantsDistinct(viewChangeMsgSet, (preprep, prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofSize(viewChangeMsgSet, x, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofNumDistinctParticipants(viewChangeMsgSet, x, l, t)

# viewChangeMsgSet well formed condition [8b]
viewChangeMsgSetUncheckpointedPreparedProofMinView(viewChangeMsgSet, (preprep, prepareCert), min<msgView>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((msgView, _, _, _), _))

viewChangeMsgSetUncheckpointedPreparedProofMaxView(viewChangeMsgSet, (preprep, prepareCert), max<msgView>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((msgView, _, _, _), _))

viewChangeMsgSetUncheckpointedPreparedProofViewsMatch(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofMinView(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), msgView, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofMaxView(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), msgView, l, t)

# viewChangeMsgSet well formed condition [8c]
viewChangeMsgSetUncheckpointedPreparedProofMinSeqNum(viewChangeMsgSet, (preprep, prepareCert), min<n>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, n, _, _), _))

viewChangeMsgSetUncheckpointedPreparedProofMaxSeqNum(viewChangeMsgSet, (preprep, prepareCert), max<n>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, n, _, _), _))

viewChangeMsgSetUncheckpointedPreparedProofSeqNumsMatch(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofMinSeqNum(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), n, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofMaxSeqNum(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), n, l, t)

# viewChangeMsgSet well formed condition [8d]
viewChangeMsgSetUncheckpointedPreparedProofMinDigest(viewChangeMsgSet, (preprep, prepareCert), min<d>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, _, d, _), _))

viewChangeMsgSetUncheckpointedPreparedProofMaxDigest(viewChangeMsgSet, (preprep, prepareCert), max<d>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, _, d, _), _))

viewChangeMsgSetUncheckpointedPreparedProofDigestsMatch(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofMinDigest(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), d, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofMaxDigest(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), d, l, t)

# viewChangeMsgSet well formed condition [8e]
viewChangeMsgSetUncheckpointedPreparedProofNumValidSignatures(viewChangeMsgSet, (preprep, prepareCert), count<sig>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((msgView, n, d, l'), sig)),
    publicKeyStore(pk, l'),
    verifySignature(pk, (msgView, n, d, l'), sig)

viewChangeMsgSetUncheckpointedPreparedProofSignaturesValid(viewChangeMsgSet, (preprep, prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofNumValidSignatures(viewChangeMsgSet, (preprep, prepareCert), numSig, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofSize(viewChangeMsgSet, (preprep, prepareCert), numSig, l, t)

# viewChangeMsgSet well formed condition [8f]
viewChangeMsgSetUncheckpointedPreparedProofPreprepareSignatureValid(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), count<sig>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (((msgView, n, d), preprepSig), prepareCert)),
    viewPrimary(msgView, l'),
    publicKeyStore(pk, l'),
    verifySignature(pk, (msgView, n, d), preprepSig)

// ASK?: is there a strict requirement on whether or not we should accept new-view messages with views higher than our own? accepting new-view messages with lower views should not change anything in practice, but just wondering
# accepted new-view messages
newViewLog(v', viewChangeMsgSet, O, sig, l', l, t) :-
    newViewWellFormedIn((v', viewChangeMsgSet, O), sig, l', l, t), # is well formed
    viewChangeMessageSetByView(v', viewChangeMsgSet, l, t), # is the first new-view message in this view
    newViewPreparedSetFromViewChangeSet(viewChangeMsgSet, O, l, t) # its O set matches the one we would've created

# potential views based on accepted new-view messages
enteredViews(v, l, t) :-
    newViewLog(v, _, _, _, _, l, t)

# initialize with view 0
enteredViews(v, l, t) :-
    ZERO(v)

# current view is based on highest accepted new-view message
currentView(max<v>, l, t) :-
    enteredViews(v, l, t)

# choose is used in case multiple new-view messages for the same view are received in the same timestep
onlyOneViewChangeMessageSet(v', choose<viewChangeMsgSet>, l, t) :-
    currentView(v, l, t),
    v' = v + 1,
    ¬viewPrimary(v', l),
    newViewWellFormedIn((v', viewChangeMsgSet, _), _, _, l, t),
    ¬viewChangeMessageSetByView(v', _, l, t)

# persist chosen viewChangeMsgSets
onlyOneViewChangeMessageSet(v', viewChangeMsgSet, l, t') :-
    onlyOneViewChangeMessageSet(v', viewChangeMsgSet, l, t),
    next(t, t')

# if not the primary, will take the first new-view message given by the primary
viewChangeMessageSetByView(v', viewChangeMsgSet, l, t') :-
    currentView(v, l, t),
    v' = v + 1,
    ¬viewPrimary(v', l),
    newViewWellFormedIn((v', viewChangeMsgSet, _), _, _, l, t),
    onlyOneViewChangeMessageSet(v', viewChangeMsgSet, l, t),
    next(t, t')

########## end verifying new-view messages

// ASK?: if there are multiple duplicate rows in a relation, will future relations that reference these rules in their body also be prone to duplicates (assuming they don't aggregate)?
// ASK: do i assume that rules are evaluated in top-to-bottom order? so a rule can't reference relations that only have rules below it, and i should assume that only the rules before it are evaluated for the current timestep by the time its evaluated? ans: only rules with aggregations/negations have all rules in the body fully evaluated before the head is evaluated, every other rule can be evaluated as soon as each rule in the body has a fact
// ASK: when do we actually send the checkpoint state s?
// ASK: when transitioning into a new view v', we multicast new prepare messages in view v' to all replicas (many of which may not be in the new view yet, and will therefore reject the message); do we keep resending these prepare messages (and when do we know to stop, if so)?