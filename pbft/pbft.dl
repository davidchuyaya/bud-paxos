// TODO: [x] create viewChangeMessageSetByView to prevent relying on a magic relation that doesnt exist (contains)
// TODO: [x] new view log (verifying the O set)
// TODO: [x] add liveness view change multicast pseudocode
// TODO: [x] implement view-transition true/false state to prevent accepting consensus messages during view changes
// TODO: [x] define channel to send commands to execution
// TODO: [x] define channel to take in results of executing commands (to send to client)
// TODO: [x] define channel to take in copy of state machine state (to send for checkpointing)
// TODO: [x] create checkpointing logic
// TODO: [x] account for watermarks in log messages
// TODO: [x] create logic to find missing client messages + checkpoint states
// TODO: [x] rework snapshots so that they silently arrive instead of being requested
// TODO: [x] take stable checkpoint proofs from accepted new view messages
// TODO: [x] take/send prepreps + prepares from the O set of accepted new view messages before entering the next view
// TODO: [x] add ability to replace the current state with later stable checkpoint snapshot
// TODO: implement client message sequencing
// TODO: add in and rework david's critical path code
// TODO: comments
// TODO: remove all parentheses in outboxes
// TODO: remove all ls and ts to adhere to shadaj syntax
// TODO: find which relations are garbage collected and leave question marks for those that you're unsure about (like watermarks)
// TODO: how to garbage collect with checkpoints? oooh the condition in msgLog that requires seqNum >= h might have a double use
// TODO: client implementation (if no response from primary broadcast to all nodes)

// NOTE: need to check that i don't rely on the existence of duplicate rows
// NOTE: need to check that all mentions of the client request message include the client signature
// NOTE: need to check that piggybacked preprepare/bare preprepare split is done correctly
// ∈
########## EDBs

# EDBs provided by the system
ZERO(n)
next(t, t')
publicKeyStore(pk, l)
privateKeyStore(sk, l)
verifySignature(pk, msg, sig)
signMsg(sk, msg, sig)
digest(msg, d) # d is the digest of msg
contains(set, elem) # set contains elem
replicas(l) # one row per replica l

# EDBs created for this protocol
FAILURES(f)
NO_OP(op)
WATERMARK_WIDTH(k)
CHECKPOINT_INTERVAL(k)
REQUEST_EXPIRATION(delta)
NEW_VIEW_EXPIRATION(delta)
INITIAL_STATE_DIGEST(d)
viewPrimary(v, l)

########## end EDBs



########## IDBs

STATE_MACHINE(l') # the replica's own state machine

########## end IDBs



########## client requests

requestVerifiedIn((o, clientTimestamp, l'), sig, l', l, t) :-
    requestIn((o, clientTimestamp, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (o, clientTimestamp, l'), sig)

// ASK: say the client sends a request to a byzantine primary, who ignores it; the client then broadcasts this request to all replicas, who start a timer upon receiving it; say the timer expires, since only the primary can kick off the consensus process and this request hasnt satisfied the prepared predicate, is it just dropped/ignored when replicas move into the next view? does the new primary automatically kick off the consensus process with all "orphaned" requests? ans: the new primary should kick off the consensus process with orphaned requests, if a client broadcasts a message it should eventually be committed
requestLog(o, clientTimestamp, l', sig, l, t) :-
    requestVerifiedIn((o, clientTimestamp, l'), sig, l', l, t), # contacted directly
    ¬attemptingViewChange(_, l, t),

requestLog(o, clientTimestamp, l', sig, l, t) :-
    piggybackedPreprepareLog(_, _, _, o, clientTimestamp, l', sig, l, t), # taken from a piggybacked preprepare

########## end client requests



########## critical path

piggybackedPreprepareVerifiedIn((v, n, d), sig, (o, clientTimestamp, clientLocation), clientSig, l', l, t) :-
    piggybackedPreprepareIn((v, n, d), sig, (o, clientTimestamp, clientLocation), l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v, n, d), sig)
    publicKeyStore(pk, clientLocation),
    verifySignature(pk, (o, clientTimestamp, clientLocation), clientSig)

piggybackedPreprepareLog(v, n, d, sig, o, clientTimestamp, clientLocation, clientSig, l, t) :-
    piggybackedPreprepareVerifiedIn((v, n, d), sig, (o, clientTimestamp, clientLocation), clientSig, l', l, t),
    ¬attemptingViewChange(_, l, t),
    viewPrimary(v, l'),
    digest(o, d),
    currentView(v, l, t),
    ¬preprepareLog(v, n, d', _, l, t),
    d != d',
    lowWatermark(h, l, t),
    h < n,
    WATERMARK_WIDTH(k),
    n < h + k

preprepareLog(v, n, d, sig, l, t) :-
    piggybackedPreprepareLog(v, n, d, sig, _, _, _, _, l, t)

prepareVerifiedIn((v, n, d, l'), sig, l', l, t) :-
    prepareIn((v, n, d, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v, n, d, l'), sig)

prepareLog(v, n, d, l', sig, l, t) :-
    prepareVerifiedIn((v, n, d, l'), sig, l', l, t),
    ¬attemptingViewChange(_, l, t),
    currentView(v, l, t),
    lowWatermark(h, l, t),
    h < n,
    WATERMARK_WIDTH(k),
    n < h + k

########## end critical path



########## message commit

prepareCertSize(v, n, d, count<l'>, l, t) :-
    prepareLog(v, n, d, l', _, l, t)

# has a preprepare and 2f + 1 matching prepares
digestPrepared(d, v, n, l, t) :-
    preprepareLog(v, n, d, _, l, t),
    prepareCertSize(v, n, d, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# additionally has the original request logged
prepared(((o, clientTimestamp, c), clientSig), v, n, l, t) :-
    requestLog(o, clientTimestamp, c, clientSig, l, t),
    digestPrepared(d, v, n, l, t),
    digest(((o, clientTimestamp, c), clientSig), d)

commitOutbox((v, n, d, l), l, t) :-
    prepared(m, v, n, l, t),
    digest(m, d)

commitSent((v, n, d, l), l, t') :-
    commitOutbox((v, n, d, l), l, t),
    next(t, t')

commitSent((v, n, d, l), l, t') :-
    commitSent((v, n, d, l), l, t),
    next(t, t')

commitIn((v, n, d, l), sig, l, l', t')@async :-
    commitOutbox((v, n, d, l), l, t),
    ¬commitSent((v, n, d, l), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (v, n, d, l), sig),
    replicas(l')

commitVerifiedIn((v, n, d, l'), sig, l', l, t) :-
    commitIn((v, n, d, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v, n, d, l'), sig)

commitLog(v, n, d, l', sig, l, t) :-
    ¬attemptingViewChange(_, l, t),
    ... # accepted commits

########## end message commit



########## command execution + client reply

committedLocal(((o, clientTimestamp, l'), clientSig), v, n, l, t) :-
    prepared(((o, clientTimestamp, l'), clientSig), v, n, l, t),
    ...

// ASK: since messages can be reordered, can i assume that the state machine can execute requests sequentially based on the seq nums i provide it? and therefore i don't need to send it commands in order? ans: yes
executeCommandOutbox((o, n), l, t) :-
    committedLocal((o, _, _), _, n, l, t)

executeCommandSent((o, n), l, t') :-
    executeCommandOutbox((o, n), l, t),
    next(t, t')

executeCommandSent((o, n), l, t') :-
    executeCommandSent((o, n), l, t),
    next(t, t')

executeCommandIn((o, n), sig, l, l', t')@async :-
    executeCommandOutbox((o, n), l, t),
    ¬executeCommandSent((o, n), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (o, n), sig),
    STATE_MACHINE(l')

executeCommandReplyIn((o, n, res), sig, l, l', t)@async :-
    ... # reply sent via input channel

executeCommandReplyVerifiedIn((o, n, res), sig, l', l, t) :-
    executeCommandReplyIn((o, n, res), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (o, n, res), sig)

executeCommandReplyLog(o, n, res, sig, l, t) :-
    executeCommandReplyVerifiedIn((o, n, res), sig, _, l, t)

latestExecutedCommandSeqNum(max<n>, l, t) :-
    executeCommandReplyLog(_, n, _, _, l, t)

replyOutbox((v, clientTimestamp, l', l, res), l, t) :-
    executeCommandReplyLog(o, n, res, _, l, t),
    currentView(v, l, t),
    committedLocal(((o, clientTimestamp, l'), clientSig), _, n, l, t) // NOTE: if we want the view the message was committed in use the view here

replySent((v, clientTimestamp, l', l, res), l, t') :-
    replyOutbox((v, clientTimestamp, l', l, res), l, t),
    next(t, t')

replySent((v, clientTimestamp, l', l, res), l, t') :-
    replySent((v, clientTimestamp, l', l, res), l, t),
    next(t, t')

replyIn((v, clientTimestamp, l', l, res), sig, l, l', t')@async :-
    replyOutbox((v, clientTimestamp, l', l, res), l, t),
    ¬replySent((v, clientTimestamp, l', l, res), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (v, clientTimestamp, l', l, res), sig)

########## end command execution + client reply



########## checkpointing

# the state machine will send snapshots on its own periodically through this channel
snapshotIn((n, s), sig, l, l', t')@async :-
    ... # reply sent via input channel

snapshotVerifiedIn((n, s), sig, l', l, t) :-
    snapshotIn((n, s), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (n, s), sig)

// ASK: do we have to protect against a potentially byzantine state machine? it could send the wrong state, irrelevant snapshots that don't correspond to stable checkpoints, etc.; ans: no, the state machine is decoupled so if it's byzantine the node as a whole is byzantine and so it doesn't matter
# dropped the signature to allow for other avenues of accepting snapshots (peer requests)
snapshotLog(n, s, l, t) :-
    snapshotVerifiedIn((n, s), _, _, l, t)

# broadcast checkpoint messages whenever a snapshot comes in, we defer the timing logic of snapshots to snapshotRequest
checkpointOutbox((n, d, l), l, t) :-
    snapshotLog(n, s, l, t),
    digest(s, d)

checkpointSent((n, d, l), l, t') :-
    checkpointOutbox((n, d, l), l, t),
    next(t, t')

checkpointSent((n, d, l), l, t') :-
    checkpointSent((n, d, l), l, t),
    sent(t, t')

checkpointIn((n, d, l), sig, l, l', t')@async :-
    checkpointOutbox((n, d, l), l', t),
    ¬checkpointSent((n, d, l), l', t),
    privateKeyStore(sk, l),
    signMsg(sk, (n, d, l), sig),
    replicas(l')

checkpointVerifiedIn((n, d, l'), sig, l', l, t) :-
    checkpointIn((n, d, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (n, d, l'), sig)

checkpointLog(n, d, l', sig, l, t) :-
    checkpointVerifiedIn((n, d, l'), sig, l', l, t),
    ¬checkpointLog(n, d', l', sig, l, t), # we only accept the first checkpoint message from any (n, l') pair
    d != d'

checkpointCertSize(n, d, count<l'>, l, t) :-
    checkpointLog(n, d, l', _, l, t)

stableCheckpoint(n, d, l, t) :-
    checkpointCertSize(n, d, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# initialize a blank checkpoint at -1 for watermark purposes (seq nums are zero-indexed, and checkpoints at a seq num represent the state after the seq number has been executed)
stableCheckpoint(n, d, l, t) :-
    ZERO(zero),
    n = zero - 1,
    INITIAL_STATE(d)

lowWatermark(h, l, t) :-
    lastStableCheckpoint(h, l, t)

# send request to overwrite the state if we have a stable checkpoint snapshot above our latest executed command
stateOverwriteOutbox((n', s), l, t) :-
    stableCheckpoint(n', d, l, t),
    latestExecutedCommandSeqNum(n, l, t),
    n' > n,
    snapshotLog(n', s, l, t)

stateOverwriteSent((n, s), l, t') :-
    stateOverwriteOutbox((n, s), l, t),
    next(t, t')

stateOverwriteSent((n, s), l, t') :-
    stateOverwriteSent((n, s), l, t),
    next(t, t')

# the state machine will ignore the request if its state is more recent than the snapshot
stateOverwriteIn((n, s), sig, l, l', t')@async :-
    stateOverwriteOutbox((n, s), l, t),
    ¬stateOverwriteSent((n, s), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (n, s), sig),
    STATE_MACHINE(l')

########## end checkpointing



########## view change triggers

pendingRequests(((o, clientTimestamp, c), clientSig), l, t) :-
    requestLog(o, clientTimestamp, c, clientSig, l, t),
    // TODO: committedLocal is not technically correct, we only stop the timer once we've executed the request (in practice, once we've received the result of executing the request)
    // NOTE: okay it seems like it's fine, since if it's committedLocal we know it'll be executed eventually so we can treat it as completed the consensus process
    ¬committedLocal(((o, clientTimestamp, c), clientSig), _, _, l, t)

requestCreatedTimestamps(((o, clientTimestamp, c), clientSig), t, l, t') :-
    requestLog(o, clientTimestamp, c, clientSig, l, t),
    ¬requestCreatedTimestamps(((o, clientTimestamp, c), clientSig), _, l, t)
    next(t, t')

requestCreatedTimestamps(((o, clientTimestamp, c), clientSig), timestamp, l, t') :-
    requestCreatedTimestamps(((o, clientTimestamp, c), clientSig), timestamp, l, t),
    next(t, t')

earliestPendingRequestCreatedTimestamp(min<timestamp>, l, t) :-
    pendingRequests(msg, l, t),
    requestCreatedTimestamps(msg, timestamp, l, t)

committedTimestamps(((o, clientTimestamp, c), clientSig), timestamp, l, t) :-
    ...

latestCommittedTimestamp(max<timestamp>, l, t) :-
    committedTimestamps(_, timestamp, l, t)

latestCommittedAndEarliestPendingTimestamps(timestamp, l, t) :-
    earliestPendingRequestCreatedTimestamp(timestamp, l, t)

latestCommittedAndEarliestPendingTimestamps(timestamp, l, t) :-
    latestCommittedTimestamp(timestamp, l, t)

# if there are pending requests: max(latest committed + buffer, earliest pending + buffer), otherwise infinity
requestExpiredViewChangeTimer(v', max<cutoff>, l, t) :-
    pendingRequests(_, l, t), # must have a currently pending request
    currentView(v, l, t),
    v' = v + 1, # will attempt view change for v + 1
    ¬viewChangeSent((v', _, _, _, _), l, t), # not already attempting a view change for v'; not using attemptingViewChange because that includes the timestep that the view-change is sent and negating that would cause a negation cycle
    latestCommittedAndEarliestPendingTimestamps(timestamp, l, t), # find max(latest committed + buffer, earliest pending + buffer)
    REQUEST_EXPIRATION(delta),
    cutoff = timestamp + delta # add buffer

# setup for a timer for the time between receiving 2f + 1 view-change messages but before receiving a corresponding new-view message
awaitingNewView(v', l, t) :-
    newViewReady(v', l, t),
    ¬newViewLog(v', _, _, _, _, l, t)

# start timer once receiving 2f + 1 view-changes for v', stop once new-view message for v' is received (or timer elapses)
newViewExpiredViewChangeTimer(v', cutoff, l, t) :-
    awaitingNewView(v', l, t), # waiting for a new-view for v'
    currentView(v, l, t),
    v' > v, # only attempt view change for views above ours
    ¬newViewExpiredViewChangeTimerElapsed(v, v', l, t), # no timers that have already elapsed
    numNewViewExpiredViewChangeTimersElapsed(v, x, l, t),
    NEW_VIEW_EXPIRATION(delta),
    cutoff = delta * 2 ** x # double the timer each consecutive time it's elapsed in the same view

newViewExpiredViewChangeTimerElapsed(v, v', l, t') :-
    currentView(v, l, t),
    newViewExpiredViewChangeTimer(v', cutoff, l, t),
    t >= cutoff,
    next(t, t')

newViewExpiredViewChangeTimerElapsed(v, v', l, t') :-
    newViewExpiredViewChangeTimerElapsed(v, v', l, t),
    next(t, t')

numNewViewExpiredViewChangeTimersElapsed(v, count<v'>, l, t) :-
    newViewExpiredViewChangeTimerElapsed(v, v', l, t)

# view change triggered by f + 1 view-change messages with higher views
numHigherViewChangeMessageSenders(count<l'>, l, t) :-
    currentView(v, l, t),
    viewChangeLog(v', _, _, _, l', _, l, t),
    v' > v

# take the minimum out of higher view-change messages
minHigherViewChangeMessage(min<v'>, l, t) :-
    currentView(v, l, t),
    viewChangeLog(v', _, _, _, l', _, l, t),
    v' > v

higherViewChangeTimer(v', t, l, t) :-
    numHigherViewChangeMessageSenders(x, l, t),
    FAILURES(f),
    x >= f + 1,
    minHigherViewChangeMessage(v', l, t),
    ¬higherViewChangeTimerElapsed(v', l, t)

# the timer goes "off" for one timestep 
higherViewChangeTimerElapsed(v', l, t) :-
    higherViewChangeTimer(v', cutoff, l, t),
    t >= cutoff,
    next(t, t')

higherViewChangeTimerElapsed(v', l, t') :-
    higherViewChangeTimerElapsed(v', l, t),
    next(t, t')

aggregateViewChangeTimer(v', cutoff, l, t) :-
    requestExpiredViewChangeTimer(v', cutoff, l, t)

aggregateViewChangeTimer(v', cutoff, l, t) :-
    newViewExpiredViewChangeTimer(v', cutoff, l, t)

aggregateViewChangeTimer(v', cutoff, l, t) :-
    higherViewChangeTimer(v', cutoff, l, t)

# we only care about at most one timer at a time (the closest one)
viewChangeTimer(v', min<cutoff>, l, t) :-
    aggregateViewChangeTimer(v', cutoff, l, t)

########## end view change triggers



########## creating view-change + new-view messages

stableCheckpointProof(n, d, *((n, d, l'), sig), l, t) :-
    stableCheckpoint(n, d, l, t),
    checkpointLog(n, d, l', sig, l, t)

lastStableCheckpoint(max<n>, l, t) :-
    stableCheckpoint(n, _, l, t)

preparedProof(m, v, n, ((v, n, d), preprepSig), *((v, n, d, l'), sig), l, t) :-
    prepared(m, v, n, l, t),
    preprepareLog(v, n, d, preprepSig, l, t),
    prepareLog(v, n, d, l', sig, l, t)

// filter out earlier for performance
// only send highest view, can delete messages under that
uncheckpointedPreparedProofs(*(preprep, prepareCert), l, t) :-
    preparedProof(_, _, n, preprep, prepareCert, l, t),
    lastStableCheckpoint(chkptSeqNum, l, t),
    n > chkptSeqNum

# to allow us to stop accepting consensus messages when a view change is in progress; includes the timestep the view-change message is sent out to prevent the concurrent acceptance of consensus messages
attemptingViewChange(v', l, t) :-
    viewChangeOutbox((v', _, _, _, _), l, t)

# only attempt view changes into views above the current view
attemptingViewChange(v', l, t') :-
    attemptingViewChange(v', l, t),
    currentView(v, l, t),
    v' > v,
    next(t, t')

// add negation to do exactly-once semantics and avoid spam
viewChangeOutbox((v', n, C, P, l), l, t) :-
    viewChangeTimer(v' cutoff, l, t),
    t >= cutoff,
    currentView(v, l, t),
    v' > v,
    lastStableCheckpoint(n, l, t),
    stableCheckpointProof(n, _, C, l, t),
    uncheckpointedPreparedProofs(P, l, t)

viewChangeSent((v', n, C, P, l), l, t') :-
    viewChangeOutbox((v', n, C, P, l), l, t),
    next(t, t')

viewChangeSent((v', n, C, P, l), l, t') :-
    viewChangeSent((v', n, C, P, l), l, t),
    next(t, t')

// garbage collect by not persisting (:+)
// - :+ persists stuff into the *next* timestamp
// - :- adds stuff within the same tick and nothing else
// - .persist r1 persists everything in r1 for each tick (makes it monotonic)
// ASK: why broadcast view changes to all replicas if the primary sends V anyway? will replicas ever use received view changes that aren't in V? ans: yes, for liveness (see paper)
viewChangeIn((v', n, C, P, l), sig, l, l', t')@async :-
    viewChangeOutbox((v', n, C, P, l), l, t),
    ¬viewChangeSent((v', n, C, P, l), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (v', n, C, P, l), sig),
    replicas(l')

// TODO: VIEW-CHANGE TIMER, MISC. LOG CONDITIONS
// TODO: create sets as soon as possible and make sure they don't explode cross products
viewChangeVerifiedIn((v, n, C, P, l'), sig, l', l, t) :-
    viewChangeIn((v, n, C, P, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v, n, C, P, l'), sig)

viewChangeLog(v, n, C, P, l', sig, l, t) :-
    ... # accepted view-changes
    // check i am the supposed primary of the new view? no, new primary will do check before sending out new-view messages

viewChangeCertSize(v, count<l'>, l, t) :-
    viewChangeLog(v, _, _, _, l', _, l, t)

newViewReady(v, l, t) :-
    viewChangeCertSize(v, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

viewChangeMessages(v, *((v, n, C, P, l'), sig), l, t) :-
    viewChangeLog(v, n, C, P, l', sig, l, t)

# if the primary, will create myself
# if not the primary case exists further below
viewChangeMessageSetByView(v, viewChangeMsgSet, l, t) :-
    viewPrimary(v, l),
    viewChangeMessages(v, viewChangeMsgSet, l, t)

# viewChangeMsgSet => *((v, n, C, P, l'), sig)
# all "FromViewChangeSet" assumes viewChangeMsgSet is well-formed
latestStableCheckpointSeqNumFromViewChangeSet(viewChangeMsgSet, max<chkptSeqNum>, l, t) :-
    viewChangeMessageSetByView(_, viewChangeMsgSet, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((chkptSeqNum, _, _), _))

# min-s
latestPrepareSeqNumFromViewChangeSet(viewChangeMsgSet, max<prepSeqNum>, l, t) :-
    viewChangeMessageSetByView(_, viewChangeMsgSet, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (((_, prepSeqNum, _), _), _))

# max-s
highestPreparedProofViewBySeqNumFromViewChangeSet(viewChangeMsgSet, n, max<msgView>, l, t) :-
    viewChangeMessageSetByView(_, viewChangeMsgSet, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (((msgView, n, _), _), _))

# there is an operation with seq number n in P
highestViewPreparedMessageDigestBySeqNumFromViewChangeSet(viewChangeMsgSet, n, d, l, t) :-
    highestPreparedProofViewBySeqNumFromViewChangeSet(viewChangeMsgSet, n, highestProofView, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (((highestProofView, n, d), _), _)), # should only have one unique value of d

# no operation exists for seq number min-s < n <= max-s in P
emptyBoundedSeqNumsFromViewChangeSet(viewChangeMsgSet, n, l, t) :-
    latestStableCheckpointSeqNumFromViewChangeSet(viewChangeMsgSet, minSeqNum, l, t),
    latestPrepareSeqNumFromViewChangeSet(viewChangeMsgSet, maxSeqNum, l, t),
    minSeqNum < n <= maxSeqNum,
    ¬highestViewPreparedMessageDigestBySeqNumFromViewChangeSet(viewChangeMsgSet, n, _, l, t)

// ASK: is the set operator by rule or by table? this also applies to aggregates in general; ans: by rule
// in other words, does

// a(*u) :-
//     f(u)

// a(*v) :-
//     g(v)

// equal?

// b(u) :-
//     f(u)

// b(v) :-
//     g(v)

// a(*w) :-
//     b(w)

// or does the first example instead create two different rows, one for both f and g?

// ASK: can i even do? in other words, does datalog type-check at all? side question, what about tuples? ans: yes assume things are strongly type checked

// a(*u) :-
//     f(u)

// a(v) :-
//     g(v)

// why it is relevant: a = O set, f(u) = a message exists in the P set for seq number n, g(v) = no message exists in the P set for seq number n (and therefore we need a no-op)

# first case for an element in the O set (the message in P with the highest view under the seq number n)
newViewPreparedMessagesFromViewChangeSet(viewChangeMsgSet, ((v', n, d), sig), l, t) :-
    contains(viewChangeMsgSet, ((v', _, _, _, _), _)), # should only be one v'
    highestViewPreparedMessageDigestBySeqNumFromViewChangeSet(viewChangeMsgSet, n, d, l, t),
    latestStableCheckpointSeqNumFromViewChangeSet(viewChangeMsgSet, minSeqNum, l, t),
    latestPrepareSeqNumFromViewChangeSet(viewChangeMsgSet, maxSeqNum, l, t),
    minSeqNum < n <= maxSeqNum, // could bound seq nums earlier for performance
    privateKeyStore(sk, l),
    signMsg(sk, (v', n, d), sig)

# second case for an element in the O set (no message in P, no-op)
newViewPreparedMessagesFromViewChangeSet(viewChangeMsgSet, ((v', n, d), sig), l, t) :-
    contains(viewChangeMsgSet, ((v', _, _, _, _), _)), # should only be one v'
    emptySeqNumsFromViewChangeSet(viewChangeMsgSet, n, l, t),
    NO_OP(op),
    digest(op, d), // could just save the no-op digest directly for performance
    privateKeyStore(sk, l),
    signMsg(sk, (v', n, d), sig)

# combining both cases into the O set
newViewPreparedSetFromViewChangeSet(viewChangeMsgSet, *((v', n, d), sig), l, t) :-
    newViewPreparedMessagesFromViewChangeSet(viewChangeMsgSet, ((v', n, d), sig), l, t)

# new-view messages from other primaries are mixed with those meant to be sent by us, but we only send those for views in which we're the primary
newViewOutbox((v', viewChangeMsgSet, O), l, t) :-
    currentView(v, l, t),
    v' = v + 1,
    viewPrimary(v', l),
    newViewReady(v', l, t),
    viewChangeMessages(v', viewChangeMsgSet, l, t),
    newViewPreparedSetFromViewChangeSet(viewChangeMsgSet, O, l, t)

newViewSent((v', viewChangeMsgSet, O), l, t') :-
    newViewOutbox((v', viewChangeMsgSet, O), l, t),
    next(t, t')

newViewSent((v', viewChangeMsgSet, O), l, t') :-
    newViewSent((v', viewChangeMsgSet, O), l, t),
    next(t, t')

newViewIn((v', viewChangeMsgSet, O), sig, l, l', t')@async :-
    newViewOutbox((v', viewChangeMsgSet, O), l, t),
    ¬newViewSent((v', viewChangeMsgSet, O), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (v', viewChangeMsgSet, O), sig),
    replicas(l')

########## end creating view-change + new-view messages



########## verifying new-view messages

newViewVerifiedIn((v', viewChangeMsgSet, O), sig, l', l, t) :-
    newViewIn((v', viewChangeMsgSet, O), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v', viewChangeMsgSet, O), sig)

# new-view viewChangeMsgSet well formed conditions:
# - [1] at least v_n >= 2f + 1 view-change messages
# - [1] exactly v_n distinct l' values
// TODO: change to eq/dont eq syntax
# - [2] min v' in viewChangeMsgSet equals v' in the new-view
# - [2] max v' in viewChangeMsgSet equals v' in the new-view
# - [3] all view-change signatures work according to their l'
# - [4] at least c_n >= 2f + 1 checkpoint messages in C
# - [4] exactly c_n distinct l' values
# - [5] min n in C equals the n in the view-change message
# - [5] max n in C equals the n in the view-change message
# - [6] min d in C equals max d in C
# - [7] all checkpoint signatures work according to their l'
# - [8] each (preprep, prepCert) in P:
#     - [8a] at least p_n >= 2f + 1 prepare messages
#     - [8a] exactly p_n distinct l' values
#     - [8b] min v in prepCert equals v in preprep
#     - [8b] max v in prepCert equals v in preprep
#     - [8c] min n in prepCert equals n in preprep
#     - [8c] max n in prepCert equals n in preprep
#     - [8d] min d in prepCert equals d in preprep
#     - [8d] max d in prepCert equals d in preprep
#     - [8e] all prepCert signatures work according to their l'
#     - [8f] the preprep signature works according to the primary of v

newViewWellFormedIn((v', viewChangeMsgSet, O), sig, l', l, t) :-
    newViewVerifiedIn((v', viewChangeMsgSet, O), sig, l', l, t),
    viewChangeMsgSetMeetsMinimumSize(viewChangeMsgSet, l, t),
    viewChangeMsgSetParticipantsDistinct(viewChangeMsgSet, l, t),
    viewChangeMsgSetViewsMatch(viewChangeMsgSet, l, t),
    viewChangeMsgSetSignaturesValid(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofMeetsMinimumSize(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofParticipantsDistinct(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofSeqNumsMatch(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofDigestsMatch(viewChangeMsgSet, l, t),
    viewChangeMsgSetStableCheckpointProofSignaturesValid(viewChangeMsgSet, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofsWellFormed(viewChangeMsgSet, l, t)

# viewChangeMsgSet well formed condition [1]
viewChangeMsgSetSize(viewChangeMsgSet, count<l'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, _, l'), _))

viewChangeMsgSetParticipantSet(viewChangeMsgSet, *l', l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, _, l'), _))

viewChangeMsgSetNumDistinctParticipants(viewChangeMsgSet, count<l'>, l, t) :-
    viewChangeMsgSetParticipantSet(viewChangeMsgSet, participantSet, l, t),
    contains(participantSet, l')

# at least 2f + 1 distinct l' in viewChangeMsgSet
viewChangeMsgSetMeetsMinimumSize(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetNumDistinctParticipants(viewChangeMsgSet, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# no duplicate l' in viewChangeMsgSet
viewChangeMsgSetParticipantsDistinct(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetSize(viewChangeMsgSet, x, l, t),
    viewChangeMsgSetNumDistinctParticipants(viewChangeMsgSet, x, l, t)

# viewChangeMsgSet well formed condition [2]
viewChangeMsgSetMinView(viewChangeMsgSet, min<v'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((v', _, _, _, _), _))

viewChangeMsgSetMaxView(viewChangeMsgSet, max<v'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((v', _, _, _, _), _))

viewChangeMsgSetViewsMatch(viewChangeMsgSet, l, t) :-
    newViewVerifiedIn((v', viewChangeMsgSet, _), _, _, l, t),
    viewChangeMsgSetMinView(viewChangeMsgSet, v', l, t),
    viewChangeMsgSetMaxView(viewChangeMsgSet, v', l, t)

# viewChangeMsgSet well formed condition [3]
viewChangeMsgSetNumValidSignatures(viewChangeMsgSet, count<sig>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((v', n, C, P, l'), sig)),
    publicKeyStore(pk, l'),
    verifySignature(pk, (v', n, C, P, l'), sig)

viewChangeMsgSetSignaturesValid(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetNumValidSignatures(viewChangeMsgSet, numSig, l, t),
    viewChangeMsgSetSize(viewChangeMsgSet, numSig, l, t)

# viewChangeMsgSet well formed condition [4]
viewChangeMsgSetStableCheckpointProofSize(viewChangeMsgSet, count<l'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((_, _, l'), _))

viewChangeMsgSetStableCheckpointProofParticipantSet(viewChangeMsgSet, l*, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((_, _, l'), _))

viewChangeMsgSetStableCheckpointProofNumDistinctParticipants(viewChangeMsgSet, count<l'>, l, t) :-
    viewChangeMsgSetStableCheckpointProofParticipantSet(viewChangeMsgSet, participantSet, l, t),
    contains(participantSet, l')

# at least 2f + 1 distinct l' in viewChangeMsgSet's C set
viewChangeMsgSetStableCheckpointProofMeetsMinimumSize(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetStableCheckpointProofNumDistinctParticipants(viewChangeMsgSet, certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# no duplicate l' in viewChangeMsgSet's C set
viewChangeMsgSetStableCheckpointProofParticipantsDistinct(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetStableCheckpointProofSize(viewChangeMsgSet, x, l, t),
    viewChangeMsgSetStableCheckpointProofNumDistinctParticipants(viewChangeMsgSet, x, l, t)

# viewChangeMsgSet well formed condition [5]
viewChangeMsgSetStableCheckpointProofMinSeqNum(viewChangeMsgSet, min<n>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((n, _, _), _))

viewChangeMsgSetStableCheckpointProofMaxSeqNum(viewChangeMsgSet, max<n>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((n, _, _), _))

viewChangeMsgSetStableCheckpointProofSeqNumsMatch(viewChangeMsgSet, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, n, _, _, _), _)),
    viewChangeMsgSetStableCheckpointProofMinSeqNum(viewChangeMsgSet, n, l, t),
    viewChangeMsgSetStableCheckpointProofMaxSeqNum(viewChangeMsgSet, n, l, t)

# viewChangeMsgSet well formed condition [6]
viewChangeMsgSetStableCheckpointProofMinDigest(viewChangeMsgSet, min<d>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((_, d, _), _))

viewChangeMsgSetStableCheckpointProofMaxDigest(viewChangeMsgSet, max<d>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((_, d, _), _))

viewChangeMsgSetStableCheckpointProofDigestsMatch(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetStableCheckpointProofMinDigest(viewChangeMsgSet, d, l, t),
    viewChangeMsgSetStableCheckpointProofMaxDigest(viewChangeMsgSet, d, l, t)

# viewChangeMsgSet well formed condition [7]
viewChangeMsgSetStableCheckpointProofNumValidSignatures(viewChangeMsgSet, count<sig>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((n, d, l'), sig)),
    publicKeyStore(pk, l'),
    verifySignature(pk, (n, d, l'), sig)

viewChangeMsgSetStableCheckpointProofSignaturesValid(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetStableCheckpointProofNumValidSignatures(viewChangeMsgSet, numSig, l, t),
    viewChangeMsgSetStableCheckpointProofSize(viewChangeMsgSet, numSig, l, t)

# viewChangeMsgSet well formed condition [8]
viewChangeMsgSetUncheckpointedPreparedProofs(viewChangeMsgSet, *(preprep, prepareCert), l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert))

viewChangeMsgSetUncheckpointedValidPreparedProofs(viewChangeMsgSet, *(preprep, prepareCert), l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    viewChangeMsgSetUncheckpointedPreparedProofMeetsMinimumSize(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofParticipantsDistinct(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofViewsMatch(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofSeqNumsMatch(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofDigestsMatch(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofSignaturesValid(viewChangeMsgSet, (preprep, prepareCert), l, t),
    viewChangeMsgSetUncheckpointedPreparedProofPreprepareSignatureValid(viewChangeMsgSet, (preprep, prepareCert), l, t)

viewChangeMsgSetUncheckpointedPreparedProofsWellFormed(viewChangeMsgSet, l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofs(viewChangeMsgSet, P, l, t),
    viewChangeMsgSetUncheckpointedValidPreparedProofs(viewChangeMsgSet, P, l, t)

# viewChangeMsgSet well formed condition [8a]
viewChangeMsgSetUncheckpointedPreparedProofSize(viewChangeMsgSet, (preprep, prepareCert), count<l'>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, _, _, l'), _))

viewChangeMsgSetUncheckpointedPreparedProofParticipantSet(viewChangeMsgSet, (preprep, prepareCert), *l', l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, _, _, l'), _))

viewChangeMsgSetUncheckpointedPreparedProofNumDistinctParticipants(viewChangeMsgSet, (preprep, prepareCert), count<l'>, l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofParticipantSet(viewChangeMsgSet, (preprep, prepareCert), participantSet, l, t),
    contains(participantSet, l')

# at least 2f + 1 distinct l' in the uncheckpointed prepared proof
viewChangeMsgSetUncheckpointedPreparedProofMeetsMinimumSize(viewChangeMsgSet, (preprep, prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofNumDistinctParticipants(viewChangeMsgSet, (preprep, prepareCert), certSize, l, t),
    FAILURES(f),
    certSize >= 2 * f + 1

# no duplicate l' in the uncheckpointed prepared proof
viewChangeMsgSetUncheckpointedPreparedProofParticipantsDistinct(viewChangeMsgSet, (preprep, prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofSize(viewChangeMsgSet, x, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofNumDistinctParticipants(viewChangeMsgSet, x, l, t)

# viewChangeMsgSet well formed condition [8b]
viewChangeMsgSetUncheckpointedPreparedProofMinView(viewChangeMsgSet, (preprep, prepareCert), min<msgView>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((msgView, _, _, _), _))

viewChangeMsgSetUncheckpointedPreparedProofMaxView(viewChangeMsgSet, (preprep, prepareCert), max<msgView>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((msgView, _, _, _), _))

viewChangeMsgSetUncheckpointedPreparedProofViewsMatch(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofMinView(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), msgView, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofMaxView(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), msgView, l, t)

# viewChangeMsgSet well formed condition [8c]
viewChangeMsgSetUncheckpointedPreparedProofMinSeqNum(viewChangeMsgSet, (preprep, prepareCert), min<n>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, n, _, _), _))

viewChangeMsgSetUncheckpointedPreparedProofMaxSeqNum(viewChangeMsgSet, (preprep, prepareCert), max<n>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, n, _, _), _))

viewChangeMsgSetUncheckpointedPreparedProofSeqNumsMatch(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofMinSeqNum(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), n, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofMaxSeqNum(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), n, l, t)

# viewChangeMsgSet well formed condition [8d]
viewChangeMsgSetUncheckpointedPreparedProofMinDigest(viewChangeMsgSet, (preprep, prepareCert), min<d>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, _, d, _), _))

viewChangeMsgSetUncheckpointedPreparedProofMaxDigest(viewChangeMsgSet, (preprep, prepareCert), max<d>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((_, _, d, _), _))

viewChangeMsgSetUncheckpointedPreparedProofDigestsMatch(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofMinDigest(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), d, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofMaxDigest(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), d, l, t)

# viewChangeMsgSet well formed condition [8e]
viewChangeMsgSetUncheckpointedPreparedProofNumValidSignatures(viewChangeMsgSet, (preprep, prepareCert), count<sig>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (preprep, prepareCert)),
    contains(prepareCert, ((msgView, n, d, l'), sig)),
    publicKeyStore(pk, l'),
    verifySignature(pk, (msgView, n, d, l'), sig)

viewChangeMsgSetUncheckpointedPreparedProofSignaturesValid(viewChangeMsgSet, (preprep, prepareCert), l, t) :-
    viewChangeMsgSetUncheckpointedPreparedProofNumValidSignatures(viewChangeMsgSet, (preprep, prepareCert), numSig, l, t),
    viewChangeMsgSetUncheckpointedPreparedProofSize(viewChangeMsgSet, (preprep, prepareCert), numSig, l, t)

# viewChangeMsgSet well formed condition [8f]
viewChangeMsgSetUncheckpointedPreparedProofPreprepareSignatureValid(viewChangeMsgSet, (((msgView, n, d), preprepSig), prepareCert), count<sig>, l, t) :-
    newViewVerifiedIn((_, viewChangeMsgSet, _), _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, _, P, _), _)),
    contains(P, (((msgView, n, d), preprepSig), prepareCert)),
    viewPrimary(msgView, l'),
    publicKeyStore(pk, l'),
    verifySignature(pk, (msgView, n, d), preprepSig)

// ASK: is there a strict requirement on whether or not we should accept new-view messages with views higher than our own? accepting new-view messages with lower views should not change anything in practice, but just wondering; ans: you can ignore all messages with lower views
# accepted new-view messages
newViewLog(v', viewChangeMsgSet, O, sig, l', l, t) :-
    newViewWellFormedIn((v', viewChangeMsgSet, O), sig, l', l, t), # is well formed
    viewChangeMessageSetByView(v', viewChangeMsgSet, l, t), # is the first new-view message in this view
    newViewPreparedSetFromViewChangeSet(viewChangeMsgSet, O, l, t) # its O set matches the one we would've created

# potential views based on accepted new-view messages
enteredViews(v, l, t) :-
    newViewLog(v, _, _, _, _, l, t)

# initialize with view 0
enteredViews(v, l, t) :-
    ZERO(v)

# current view is based on highest accepted new-view message
currentView(max<v>, l, t) :-
    enteredViews(v, l, t)

# choose is used in case multiple new-view messages for the same view are received in the same timestep
onlyOneViewChangeMessageSet(v', choose<viewChangeMsgSet>, l, t) :-
    currentView(v, l, t),
    v' = v + 1,
    ¬viewPrimary(v', l),
    newViewWellFormedIn((v', viewChangeMsgSet, _), _, _, l, t),
    ¬viewChangeMessageSetByView(v', _, l, t)

# persist chosen viewChangeMsgSets
onlyOneViewChangeMessageSet(v', viewChangeMsgSet, l, t') :-
    onlyOneViewChangeMessageSet(v', viewChangeMsgSet, l, t),
    next(t, t')

# if not the primary, will take the first new-view message given by the primary
viewChangeMessageSetByView(v', viewChangeMsgSet, l, t') :-
    currentView(v, l, t),
    v' = v + 1,
    ¬viewPrimary(v', l),
    newViewWellFormedIn((v', viewChangeMsgSet, _), _, _, l, t),
    onlyOneViewChangeMessageSet(v', viewChangeMsgSet, l, t),
    next(t, t')

########## end verifying new-view messages



########## adding preprepare + checkpoint messages from new-view messages

preprepareLog(v, n, d, sig, l, t) :-
    newViewLog(v, _, O, _, _, l, t),
    contains(O, ((v, n, d), sig))

checkpointIn((n, d, l'), sig, l', l, t) :-
    newViewLog(v, viewChangeMsgSet, _, _, _, l, t),
    contains(viewChangeMsgSet, ((_, _, C, _, _), _)),
    contains(C, ((n, d, l'), sig))

########## end adding preprepare + checkpoint messages from new-view messages



########## retrieving missing checkpoint

# if i have a stable checkpoint but i don't have the corresponding snapshot send out requests
peerSnapshotRequestOutbox((l, n), l, t) :-
    stableCheckpoint(n, d, l, t),
    lastStableCheckpoint(n, l, t),
    ¬snapshotLog(n, _, l, t)

peerSnapshotRequestSent((l, n), l, t') :-
    peerSnapshotRequestOutbox((l, n), l, t),
    next(t, t')

peerSnapshotRequestSent((l, n), l, t') :-
    peerSnapshotRequestSent((l, n), l, t),
    next(t, t')

# contact all nodes that sent me checkpoint messages for my stable checkpoint
peerSnapshotRequestIn((l, n), sig, l, l', t')@async :-
    peerSnapshotRequestOutbox((l, n), l, t),
    ¬peerSnapshotRequestSent((l, n), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (l, n), sig),
    stableCheckpointProof(n, d, C, l, t),
    contains(C, ((n, d, l'), _))

peerSnapshotRequestVerifiedIn((l', n), sig, l', l, t) :-
    peerSnapshotRequestIn((l', n), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (l', n), sig)

# if node is correct, n is guaranteed to be less than (if it's behind) or equal to (if it's caught up) than our last stable checkpoint; ignored if otherwise
peerSnapshotRequestLog(l', n, sig, l, t) :-
    peerSnapshotRequestVerifiedIn((l', n), sig, l', l, t),
    lowWatermark(h, l, t),
    n <= h

# reply with snapshot of your highest stable checkpoint
peerSnapshotRequestReplyOutbox((s, C, l'), l, t) :-
    peerSnapshotRequestLog(l', _, sig, l, t),
    lastStableCheckpoint(n, l, t),
    snapshotLog(n, s, l, t),
    stableCheckpointProof(n, _, C, l, t)

peerSnapshotRequestReplySent((s, C, l'), l, t') :-
    peerSnapshotRequestReplyOutbox((s, C, l'), l, t),
    next(t, t')

peerSnapshotRequestReplySent((s, C, l'), l, t') :-
    peerSnapshotRequestReplySent((s, C, l'), l, t),
    next(t, t')

peerSnapshotRequestReplyIn((s, C, l'), sig, l, l', t')@async :-
    peerSnapshotRequestReplyOutbox((s, C, l'), l, t),
    ¬peerSnapshotRequestReplyOutbox((s, C, l'), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (s, C, l'), sig)

peerSnapshotRequestReplyVerifiedIn((s, C, l), sig, l', l, t) :-
    peerSnapshotRequestReplyIn((s, C, l), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (s, C, l), sig)

// genius mode activated
// TODO: remove the "genius mode activated" comment
# feed checkpoint messages from sent proof into checkpointIn
checkpointIn((n, d, l'), sig, l', l, t) :-
    peerSnapshotRequestReplyVerifiedIn((_, C, _), _, _, l, t),
    contains(C, ((n, d, l'), sig))

# accept the snapshot from the reply if s now matches the digest of our last stable checkpoint
snapshotLog(n, s, l, t) :-
    peerSnapshotRequestReplyVerifiedIn((s, _, _), _, _, l, t),
    lastStableCheckpoint(n, l, t),
    stableCheckpoint(n, d, l, t),
    digest(s, d)

########## end retrieving missing checkpoint



########## retrieving missing client messages

# would satisfy the prepared predicate but is missing the original client message
peerClientMessageRequestOutbox((d, l), l, t) :-
    digestPrepared(d, v, n, l, t),
    ¬prepared(m, v, n, l, t),
    digest(m, d)

peerClientMessageRequestSent((d, l), l, t') :-
    peerClientMessageRequestOutbox((d, l), l, t),
    next(t, t')

peerClientMessageRequestSent((d, l), l, t') :-
    peerClientMessageRequestSent((d, l), l, t),
    next(t, t')

// ASK?: is broadcasting to everyone bad? should i just single out participants in the prepared/committedLocal cert?
peerClientMessageRequestIn((d, l), sig, l, l', t')@async :-
    peerClientMessageRequestOutbox((d, l), l, t),
    ¬peerClientMessageRequestSent((d, l), l, t),
    privateKeyStore(sk, l),
    signMsg(sk, (d, l), sig),
    replicas(l')

peerClientMessageRequestVerifiedIn((d, l'), sig, l', l, t) :-
    peerClientMessageRequestIn((d, l'), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (d, l'), sig)

peerClientMessageRequestLog(d, l', sig, l, t) :-
    peerClientMessageRequestVerifiedIn((d, l'), sig, l', l, t)

# have a request in my log that matches the digest d
peerClientMessageReplyOutbox((((o, clientTimestamp, clientLocation), clientSig), l'), l, t) :-
    peerClientMessageRequestLog(d, l', _, l, t),
    requestLog(o, clientTimestamp, clientLocation, clientSig, l, t),
    digest(((o, clientTimestamp, clientLocation), clientSig), d)

peerClientMessageReplySent((((o, clientTimestamp, clientLocation), clientSig), l'), l, t') :-
    peerClientMessageReplyOutbox((((o, clientTimestamp, clientLocation), clientSig), l'), l, t),
    next(t, t')

peerClientMessageReplySent((((o, clientTimestamp, clientLocation), clientSig), l'), l, t') :-
    peerClientMessageReplySent((((o, clientTimestamp, clientLocation), clientSig), l'), l, t),
    next(t, t')

peerClientMessageReplyIn((((o, clientTimestamp, clientLocation), clientSig), l'), sig, l, l', t')@async :-
    peerClientMessageReplyOutbox((((o, clientTimestamp, clientLocation), clientSig), l'), l, t),
    ¬peerClientMessageReplySent((((o, clientTimestamp, clientLocation), clientSig), l'), l, t'),
    privateKeyStore(sk, l),
    signMsg(sk, (((o, clientTimestamp, clientLocation), clientSig), l'), sig)

peerClientMessageReplyVerifiedIn((((o, clientTimestamp, clientLocation), clientSig), l), sig, l', l, t) :-
    peerClientMessageReplyIn((((o, clientTimestamp, clientLocation), clientSig), l), sig, l', l, t),
    publicKeyStore(pk, l'),
    verifySignature(pk, (((o, clientTimestamp, clientLocation), clientSig), l), sig)

# request matches a client message request that was sent out
requestLog(o, clientTimestamp, clientLocation, clientSig, l, t) :-
    peerClientMessageReplyVerifiedIn((((o, clientTimestamp, clientLocation), clientSig), l), sig, l', l, t),
    peerClientMessageRequestOutbox((d, l), l, t),
    digest(((o, clientTimestamp, clientLocation), clientSig), d)

########## end retrieving missing client messages

// ASK: if there are multiple duplicate rows in a relation, will future relations that reference these rules in their body also be prone to duplicates (assuming they don't aggregate)? ans: tables are sets so duplicate rows will be merged
// ASK: do i assume that rules are evaluated in top-to-bottom order? so a rule can't reference relations that only have rules below it, and i should assume that only the rules before it are evaluated for the current timestep by the time its evaluated? ans: only rules with aggregations/negations have all rules in the body fully evaluated before the head is evaluated, every other rule can be evaluated as soon as each rule in the body has a fact
// ASK: when do we actually send the checkpoint state s? ans: either periodically received from the state machine or requested from other clients
// ASK: when transitioning into a new view v', we multicast new prepare messages in view v' to all replicas (many of which may not be in the new view yet, and will therefore reject the message); do we keep resending these prepare messages (and when do we know to stop, if so)? ans: the O set (part of the new-view message) contains the preprepares, so replicas will transition into the new view and process the preprepares at the same time